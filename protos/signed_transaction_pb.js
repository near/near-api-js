/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var wrappers_pb = require('./wrappers_pb.js');
var access_key_pb = require('./access_key_pb.js');
var uint128_pb = require('./uint128_pb.js');
goog.exportSymbol('proto.AddKeyTransaction', null, global);
goog.exportSymbol('proto.CreateAccountTransaction', null, global);
goog.exportSymbol('proto.DeleteKeyTransaction', null, global);
goog.exportSymbol('proto.DeployContractTransaction', null, global);
goog.exportSymbol('proto.FunctionCallTransaction', null, global);
goog.exportSymbol('proto.SendMoneyTransaction', null, global);
goog.exportSymbol('proto.SignedTransaction', null, global);
goog.exportSymbol('proto.StakeTransaction', null, global);
goog.exportSymbol('proto.SwapKeyTransaction', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CreateAccountTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CreateAccountTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.CreateAccountTransaction.displayName = 'proto.CreateAccountTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CreateAccountTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.CreateAccountTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CreateAccountTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CreateAccountTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    originator: jspb.Message.getFieldWithDefault(msg, 2, ""),
    newAccountId: jspb.Message.getFieldWithDefault(msg, 3, ""),
    amount: (f = msg.getAmount()) && uint128_pb.Uint128.toObject(includeInstance, f),
    publicKey: msg.getPublicKey_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CreateAccountTransaction}
 */
proto.CreateAccountTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CreateAccountTransaction;
  return proto.CreateAccountTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CreateAccountTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CreateAccountTransaction}
 */
proto.CreateAccountTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOriginator(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewAccountId(value);
      break;
    case 4:
      var value = new uint128_pb.Uint128;
      reader.readMessage(value,uint128_pb.Uint128.deserializeBinaryFromReader);
      msg.setAmount(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CreateAccountTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CreateAccountTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CreateAccountTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CreateAccountTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getOriginator();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getNewAccountId();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAmount();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      uint128_pb.Uint128.serializeBinaryToWriter
    );
  }
  f = message.getPublicKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
};


/**
 * optional uint64 nonce = 1;
 * @return {number}
 */
proto.CreateAccountTransaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.CreateAccountTransaction.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string originator = 2;
 * @return {string}
 */
proto.CreateAccountTransaction.prototype.getOriginator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.CreateAccountTransaction.prototype.setOriginator = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string new_account_id = 3;
 * @return {string}
 */
proto.CreateAccountTransaction.prototype.getNewAccountId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.CreateAccountTransaction.prototype.setNewAccountId = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional Uint128 amount = 4;
 * @return {?proto.Uint128}
 */
proto.CreateAccountTransaction.prototype.getAmount = function() {
  return /** @type{?proto.Uint128} */ (
    jspb.Message.getWrapperField(this, uint128_pb.Uint128, 4));
};


/** @param {?proto.Uint128|undefined} value */
proto.CreateAccountTransaction.prototype.setAmount = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.CreateAccountTransaction.prototype.clearAmount = function() {
  this.setAmount(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CreateAccountTransaction.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bytes public_key = 5;
 * @return {!(string|Uint8Array)}
 */
proto.CreateAccountTransaction.prototype.getPublicKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes public_key = 5;
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {string}
 */
proto.CreateAccountTransaction.prototype.getPublicKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicKey()));
};


/**
 * optional bytes public_key = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {!Uint8Array}
 */
proto.CreateAccountTransaction.prototype.getPublicKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.CreateAccountTransaction.prototype.setPublicKey = function(value) {
  jspb.Message.setProto3BytesField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DeployContractTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DeployContractTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DeployContractTransaction.displayName = 'proto.DeployContractTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DeployContractTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.DeployContractTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DeployContractTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DeployContractTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    contractId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    wasmByteArray: msg.getWasmByteArray_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DeployContractTransaction}
 */
proto.DeployContractTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DeployContractTransaction;
  return proto.DeployContractTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DeployContractTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DeployContractTransaction}
 */
proto.DeployContractTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractId(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setWasmByteArray(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DeployContractTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DeployContractTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DeployContractTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DeployContractTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getContractId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getWasmByteArray_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint64 nonce = 1;
 * @return {number}
 */
proto.DeployContractTransaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.DeployContractTransaction.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string contract_id = 2;
 * @return {string}
 */
proto.DeployContractTransaction.prototype.getContractId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.DeployContractTransaction.prototype.setContractId = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes wasm_byte_array = 3;
 * @return {!(string|Uint8Array)}
 */
proto.DeployContractTransaction.prototype.getWasmByteArray = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes wasm_byte_array = 3;
 * This is a type-conversion wrapper around `getWasmByteArray()`
 * @return {string}
 */
proto.DeployContractTransaction.prototype.getWasmByteArray_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getWasmByteArray()));
};


/**
 * optional bytes wasm_byte_array = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getWasmByteArray()`
 * @return {!Uint8Array}
 */
proto.DeployContractTransaction.prototype.getWasmByteArray_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getWasmByteArray()));
};


/** @param {!(string|Uint8Array)} value */
proto.DeployContractTransaction.prototype.setWasmByteArray = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.FunctionCallTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.FunctionCallTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.FunctionCallTransaction.displayName = 'proto.FunctionCallTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.FunctionCallTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.FunctionCallTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.FunctionCallTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FunctionCallTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    originator: jspb.Message.getFieldWithDefault(msg, 2, ""),
    contractId: jspb.Message.getFieldWithDefault(msg, 3, ""),
    methodName: msg.getMethodName_asB64(),
    args: msg.getArgs_asB64(),
    amount: (f = msg.getAmount()) && uint128_pb.Uint128.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.FunctionCallTransaction}
 */
proto.FunctionCallTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.FunctionCallTransaction;
  return proto.FunctionCallTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.FunctionCallTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.FunctionCallTransaction}
 */
proto.FunctionCallTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOriginator(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractId(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMethodName(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setArgs(value);
      break;
    case 6:
      var value = new uint128_pb.Uint128;
      reader.readMessage(value,uint128_pb.Uint128.deserializeBinaryFromReader);
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.FunctionCallTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.FunctionCallTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.FunctionCallTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FunctionCallTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getOriginator();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getContractId();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getMethodName_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getArgs_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getAmount();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      uint128_pb.Uint128.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 nonce = 1;
 * @return {number}
 */
proto.FunctionCallTransaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.FunctionCallTransaction.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string originator = 2;
 * @return {string}
 */
proto.FunctionCallTransaction.prototype.getOriginator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.FunctionCallTransaction.prototype.setOriginator = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string contract_id = 3;
 * @return {string}
 */
proto.FunctionCallTransaction.prototype.getContractId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.FunctionCallTransaction.prototype.setContractId = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional bytes method_name = 4;
 * @return {!(string|Uint8Array)}
 */
proto.FunctionCallTransaction.prototype.getMethodName = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes method_name = 4;
 * This is a type-conversion wrapper around `getMethodName()`
 * @return {string}
 */
proto.FunctionCallTransaction.prototype.getMethodName_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMethodName()));
};


/**
 * optional bytes method_name = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMethodName()`
 * @return {!Uint8Array}
 */
proto.FunctionCallTransaction.prototype.getMethodName_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMethodName()));
};


/** @param {!(string|Uint8Array)} value */
proto.FunctionCallTransaction.prototype.setMethodName = function(value) {
  jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * optional bytes args = 5;
 * @return {!(string|Uint8Array)}
 */
proto.FunctionCallTransaction.prototype.getArgs = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes args = 5;
 * This is a type-conversion wrapper around `getArgs()`
 * @return {string}
 */
proto.FunctionCallTransaction.prototype.getArgs_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getArgs()));
};


/**
 * optional bytes args = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getArgs()`
 * @return {!Uint8Array}
 */
proto.FunctionCallTransaction.prototype.getArgs_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getArgs()));
};


/** @param {!(string|Uint8Array)} value */
proto.FunctionCallTransaction.prototype.setArgs = function(value) {
  jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional Uint128 amount = 6;
 * @return {?proto.Uint128}
 */
proto.FunctionCallTransaction.prototype.getAmount = function() {
  return /** @type{?proto.Uint128} */ (
    jspb.Message.getWrapperField(this, uint128_pb.Uint128, 6));
};


/** @param {?proto.Uint128|undefined} value */
proto.FunctionCallTransaction.prototype.setAmount = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.FunctionCallTransaction.prototype.clearAmount = function() {
  this.setAmount(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FunctionCallTransaction.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SendMoneyTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SendMoneyTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SendMoneyTransaction.displayName = 'proto.SendMoneyTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SendMoneyTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.SendMoneyTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SendMoneyTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SendMoneyTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    originator: jspb.Message.getFieldWithDefault(msg, 2, ""),
    receiver: jspb.Message.getFieldWithDefault(msg, 3, ""),
    amount: (f = msg.getAmount()) && uint128_pb.Uint128.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SendMoneyTransaction}
 */
proto.SendMoneyTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SendMoneyTransaction;
  return proto.SendMoneyTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SendMoneyTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SendMoneyTransaction}
 */
proto.SendMoneyTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOriginator(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setReceiver(value);
      break;
    case 4:
      var value = new uint128_pb.Uint128;
      reader.readMessage(value,uint128_pb.Uint128.deserializeBinaryFromReader);
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SendMoneyTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SendMoneyTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SendMoneyTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SendMoneyTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getOriginator();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getReceiver();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAmount();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      uint128_pb.Uint128.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 nonce = 1;
 * @return {number}
 */
proto.SendMoneyTransaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SendMoneyTransaction.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string originator = 2;
 * @return {string}
 */
proto.SendMoneyTransaction.prototype.getOriginator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SendMoneyTransaction.prototype.setOriginator = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string receiver = 3;
 * @return {string}
 */
proto.SendMoneyTransaction.prototype.getReceiver = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.SendMoneyTransaction.prototype.setReceiver = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional Uint128 amount = 4;
 * @return {?proto.Uint128}
 */
proto.SendMoneyTransaction.prototype.getAmount = function() {
  return /** @type{?proto.Uint128} */ (
    jspb.Message.getWrapperField(this, uint128_pb.Uint128, 4));
};


/** @param {?proto.Uint128|undefined} value */
proto.SendMoneyTransaction.prototype.setAmount = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SendMoneyTransaction.prototype.clearAmount = function() {
  this.setAmount(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SendMoneyTransaction.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.StakeTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.StakeTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.StakeTransaction.displayName = 'proto.StakeTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.StakeTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.StakeTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.StakeTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.StakeTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    originator: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amount: (f = msg.getAmount()) && uint128_pb.Uint128.toObject(includeInstance, f),
    publicKey: jspb.Message.getFieldWithDefault(msg, 4, ""),
    blsPublicKey: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.StakeTransaction}
 */
proto.StakeTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.StakeTransaction;
  return proto.StakeTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.StakeTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.StakeTransaction}
 */
proto.StakeTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOriginator(value);
      break;
    case 3:
      var value = new uint128_pb.Uint128;
      reader.readMessage(value,uint128_pb.Uint128.deserializeBinaryFromReader);
      msg.setAmount(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPublicKey(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setBlsPublicKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.StakeTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.StakeTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.StakeTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.StakeTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getOriginator();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      uint128_pb.Uint128.serializeBinaryToWriter
    );
  }
  f = message.getPublicKey();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getBlsPublicKey();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional uint64 nonce = 1;
 * @return {number}
 */
proto.StakeTransaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.StakeTransaction.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string originator = 2;
 * @return {string}
 */
proto.StakeTransaction.prototype.getOriginator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.StakeTransaction.prototype.setOriginator = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional Uint128 amount = 3;
 * @return {?proto.Uint128}
 */
proto.StakeTransaction.prototype.getAmount = function() {
  return /** @type{?proto.Uint128} */ (
    jspb.Message.getWrapperField(this, uint128_pb.Uint128, 3));
};


/** @param {?proto.Uint128|undefined} value */
proto.StakeTransaction.prototype.setAmount = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.StakeTransaction.prototype.clearAmount = function() {
  this.setAmount(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.StakeTransaction.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string public_key = 4;
 * @return {string}
 */
proto.StakeTransaction.prototype.getPublicKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.StakeTransaction.prototype.setPublicKey = function(value) {
  jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string bls_public_key = 5;
 * @return {string}
 */
proto.StakeTransaction.prototype.getBlsPublicKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.StakeTransaction.prototype.setBlsPublicKey = function(value) {
  jspb.Message.setProto3StringField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SwapKeyTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SwapKeyTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SwapKeyTransaction.displayName = 'proto.SwapKeyTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SwapKeyTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.SwapKeyTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SwapKeyTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SwapKeyTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    originator: jspb.Message.getFieldWithDefault(msg, 2, ""),
    curKey: msg.getCurKey_asB64(),
    newKey: msg.getNewKey_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SwapKeyTransaction}
 */
proto.SwapKeyTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SwapKeyTransaction;
  return proto.SwapKeyTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SwapKeyTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SwapKeyTransaction}
 */
proto.SwapKeyTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOriginator(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCurKey(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNewKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SwapKeyTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SwapKeyTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SwapKeyTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SwapKeyTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getOriginator();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getCurKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getNewKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional uint64 nonce = 1;
 * @return {number}
 */
proto.SwapKeyTransaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SwapKeyTransaction.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string originator = 2;
 * @return {string}
 */
proto.SwapKeyTransaction.prototype.getOriginator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SwapKeyTransaction.prototype.setOriginator = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes cur_key = 3;
 * @return {!(string|Uint8Array)}
 */
proto.SwapKeyTransaction.prototype.getCurKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes cur_key = 3;
 * This is a type-conversion wrapper around `getCurKey()`
 * @return {string}
 */
proto.SwapKeyTransaction.prototype.getCurKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCurKey()));
};


/**
 * optional bytes cur_key = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCurKey()`
 * @return {!Uint8Array}
 */
proto.SwapKeyTransaction.prototype.getCurKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCurKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.SwapKeyTransaction.prototype.setCurKey = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes new_key = 4;
 * @return {!(string|Uint8Array)}
 */
proto.SwapKeyTransaction.prototype.getNewKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes new_key = 4;
 * This is a type-conversion wrapper around `getNewKey()`
 * @return {string}
 */
proto.SwapKeyTransaction.prototype.getNewKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNewKey()));
};


/**
 * optional bytes new_key = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNewKey()`
 * @return {!Uint8Array}
 */
proto.SwapKeyTransaction.prototype.getNewKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNewKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.SwapKeyTransaction.prototype.setNewKey = function(value) {
  jspb.Message.setProto3BytesField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.AddKeyTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.AddKeyTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.AddKeyTransaction.displayName = 'proto.AddKeyTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.AddKeyTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.AddKeyTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.AddKeyTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.AddKeyTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    originator: jspb.Message.getFieldWithDefault(msg, 2, ""),
    newKey: msg.getNewKey_asB64(),
    accessKey: (f = msg.getAccessKey()) && access_key_pb.AccessKey.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.AddKeyTransaction}
 */
proto.AddKeyTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.AddKeyTransaction;
  return proto.AddKeyTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.AddKeyTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.AddKeyTransaction}
 */
proto.AddKeyTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOriginator(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNewKey(value);
      break;
    case 4:
      var value = new access_key_pb.AccessKey;
      reader.readMessage(value,access_key_pb.AccessKey.deserializeBinaryFromReader);
      msg.setAccessKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.AddKeyTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.AddKeyTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.AddKeyTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.AddKeyTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getOriginator();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getNewKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getAccessKey();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      access_key_pb.AccessKey.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 nonce = 1;
 * @return {number}
 */
proto.AddKeyTransaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.AddKeyTransaction.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string originator = 2;
 * @return {string}
 */
proto.AddKeyTransaction.prototype.getOriginator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.AddKeyTransaction.prototype.setOriginator = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes new_key = 3;
 * @return {!(string|Uint8Array)}
 */
proto.AddKeyTransaction.prototype.getNewKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes new_key = 3;
 * This is a type-conversion wrapper around `getNewKey()`
 * @return {string}
 */
proto.AddKeyTransaction.prototype.getNewKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNewKey()));
};


/**
 * optional bytes new_key = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNewKey()`
 * @return {!Uint8Array}
 */
proto.AddKeyTransaction.prototype.getNewKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNewKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.AddKeyTransaction.prototype.setNewKey = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional AccessKey access_key = 4;
 * @return {?proto.AccessKey}
 */
proto.AddKeyTransaction.prototype.getAccessKey = function() {
  return /** @type{?proto.AccessKey} */ (
    jspb.Message.getWrapperField(this, access_key_pb.AccessKey, 4));
};


/** @param {?proto.AccessKey|undefined} value */
proto.AddKeyTransaction.prototype.setAccessKey = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.AddKeyTransaction.prototype.clearAccessKey = function() {
  this.setAccessKey(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.AddKeyTransaction.prototype.hasAccessKey = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DeleteKeyTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DeleteKeyTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DeleteKeyTransaction.displayName = 'proto.DeleteKeyTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DeleteKeyTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.DeleteKeyTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DeleteKeyTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DeleteKeyTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    originator: jspb.Message.getFieldWithDefault(msg, 2, ""),
    curKey: msg.getCurKey_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DeleteKeyTransaction}
 */
proto.DeleteKeyTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DeleteKeyTransaction;
  return proto.DeleteKeyTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DeleteKeyTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DeleteKeyTransaction}
 */
proto.DeleteKeyTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOriginator(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCurKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DeleteKeyTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DeleteKeyTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DeleteKeyTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DeleteKeyTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getOriginator();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getCurKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint64 nonce = 1;
 * @return {number}
 */
proto.DeleteKeyTransaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.DeleteKeyTransaction.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string originator = 2;
 * @return {string}
 */
proto.DeleteKeyTransaction.prototype.getOriginator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.DeleteKeyTransaction.prototype.setOriginator = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes cur_key = 3;
 * @return {!(string|Uint8Array)}
 */
proto.DeleteKeyTransaction.prototype.getCurKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes cur_key = 3;
 * This is a type-conversion wrapper around `getCurKey()`
 * @return {string}
 */
proto.DeleteKeyTransaction.prototype.getCurKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCurKey()));
};


/**
 * optional bytes cur_key = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCurKey()`
 * @return {!Uint8Array}
 */
proto.DeleteKeyTransaction.prototype.getCurKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCurKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.DeleteKeyTransaction.prototype.setCurKey = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SignedTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SignedTransaction.oneofGroups_);
};
goog.inherits(proto.SignedTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SignedTransaction.displayName = 'proto.SignedTransaction';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SignedTransaction.oneofGroups_ = [[2,3,4,5,6,7,8,9]];

/**
 * @enum {number}
 */
proto.SignedTransaction.BodyCase = {
  BODY_NOT_SET: 0,
  CREATE_ACCOUNT: 2,
  DEPLOY_CONTRACT: 3,
  FUNCTION_CALL: 4,
  SEND_MONEY: 5,
  STAKE: 6,
  SWAP_KEY: 7,
  ADD_KEY: 8,
  DELETE_KEY: 9
};

/**
 * @return {proto.SignedTransaction.BodyCase}
 */
proto.SignedTransaction.prototype.getBodyCase = function() {
  return /** @type {proto.SignedTransaction.BodyCase} */(jspb.Message.computeOneofCase(this, proto.SignedTransaction.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SignedTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.SignedTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SignedTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignedTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: msg.getSignature_asB64(),
    publicKey: (f = msg.getPublicKey()) && wrappers_pb.BytesValue.toObject(includeInstance, f),
    createAccount: (f = msg.getCreateAccount()) && proto.CreateAccountTransaction.toObject(includeInstance, f),
    deployContract: (f = msg.getDeployContract()) && proto.DeployContractTransaction.toObject(includeInstance, f),
    functionCall: (f = msg.getFunctionCall()) && proto.FunctionCallTransaction.toObject(includeInstance, f),
    sendMoney: (f = msg.getSendMoney()) && proto.SendMoneyTransaction.toObject(includeInstance, f),
    stake: (f = msg.getStake()) && proto.StakeTransaction.toObject(includeInstance, f),
    swapKey: (f = msg.getSwapKey()) && proto.SwapKeyTransaction.toObject(includeInstance, f),
    addKey: (f = msg.getAddKey()) && proto.AddKeyTransaction.toObject(includeInstance, f),
    deleteKey: (f = msg.getDeleteKey()) && proto.DeleteKeyTransaction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SignedTransaction}
 */
proto.SignedTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SignedTransaction;
  return proto.SignedTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SignedTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SignedTransaction}
 */
proto.SignedTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 10:
      var value = new wrappers_pb.BytesValue;
      reader.readMessage(value,wrappers_pb.BytesValue.deserializeBinaryFromReader);
      msg.setPublicKey(value);
      break;
    case 2:
      var value = new proto.CreateAccountTransaction;
      reader.readMessage(value,proto.CreateAccountTransaction.deserializeBinaryFromReader);
      msg.setCreateAccount(value);
      break;
    case 3:
      var value = new proto.DeployContractTransaction;
      reader.readMessage(value,proto.DeployContractTransaction.deserializeBinaryFromReader);
      msg.setDeployContract(value);
      break;
    case 4:
      var value = new proto.FunctionCallTransaction;
      reader.readMessage(value,proto.FunctionCallTransaction.deserializeBinaryFromReader);
      msg.setFunctionCall(value);
      break;
    case 5:
      var value = new proto.SendMoneyTransaction;
      reader.readMessage(value,proto.SendMoneyTransaction.deserializeBinaryFromReader);
      msg.setSendMoney(value);
      break;
    case 6:
      var value = new proto.StakeTransaction;
      reader.readMessage(value,proto.StakeTransaction.deserializeBinaryFromReader);
      msg.setStake(value);
      break;
    case 7:
      var value = new proto.SwapKeyTransaction;
      reader.readMessage(value,proto.SwapKeyTransaction.deserializeBinaryFromReader);
      msg.setSwapKey(value);
      break;
    case 8:
      var value = new proto.AddKeyTransaction;
      reader.readMessage(value,proto.AddKeyTransaction.deserializeBinaryFromReader);
      msg.setAddKey(value);
      break;
    case 9:
      var value = new proto.DeleteKeyTransaction;
      reader.readMessage(value,proto.DeleteKeyTransaction.deserializeBinaryFromReader);
      msg.setDeleteKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SignedTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SignedTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SignedTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignedTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPublicKey();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      wrappers_pb.BytesValue.serializeBinaryToWriter
    );
  }
  f = message.getCreateAccount();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.CreateAccountTransaction.serializeBinaryToWriter
    );
  }
  f = message.getDeployContract();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.DeployContractTransaction.serializeBinaryToWriter
    );
  }
  f = message.getFunctionCall();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.FunctionCallTransaction.serializeBinaryToWriter
    );
  }
  f = message.getSendMoney();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.SendMoneyTransaction.serializeBinaryToWriter
    );
  }
  f = message.getStake();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.StakeTransaction.serializeBinaryToWriter
    );
  }
  f = message.getSwapKey();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.SwapKeyTransaction.serializeBinaryToWriter
    );
  }
  f = message.getAddKey();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.AddKeyTransaction.serializeBinaryToWriter
    );
  }
  f = message.getDeleteKey();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.DeleteKeyTransaction.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes signature = 1;
 * @return {!(string|Uint8Array)}
 */
proto.SignedTransaction.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes signature = 1;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.SignedTransaction.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.SignedTransaction.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.SignedTransaction.prototype.setSignature = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional google.protobuf.BytesValue public_key = 10;
 * @return {?proto.google.protobuf.BytesValue}
 */
proto.SignedTransaction.prototype.getPublicKey = function() {
  return /** @type{?proto.google.protobuf.BytesValue} */ (
    jspb.Message.getWrapperField(this, wrappers_pb.BytesValue, 10));
};


/** @param {?proto.google.protobuf.BytesValue|undefined} value */
proto.SignedTransaction.prototype.setPublicKey = function(value) {
  jspb.Message.setWrapperField(this, 10, value);
};


proto.SignedTransaction.prototype.clearPublicKey = function() {
  this.setPublicKey(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasPublicKey = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional CreateAccountTransaction create_account = 2;
 * @return {?proto.CreateAccountTransaction}
 */
proto.SignedTransaction.prototype.getCreateAccount = function() {
  return /** @type{?proto.CreateAccountTransaction} */ (
    jspb.Message.getWrapperField(this, proto.CreateAccountTransaction, 2));
};


/** @param {?proto.CreateAccountTransaction|undefined} value */
proto.SignedTransaction.prototype.setCreateAccount = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SignedTransaction.oneofGroups_[0], value);
};


proto.SignedTransaction.prototype.clearCreateAccount = function() {
  this.setCreateAccount(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasCreateAccount = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional DeployContractTransaction deploy_contract = 3;
 * @return {?proto.DeployContractTransaction}
 */
proto.SignedTransaction.prototype.getDeployContract = function() {
  return /** @type{?proto.DeployContractTransaction} */ (
    jspb.Message.getWrapperField(this, proto.DeployContractTransaction, 3));
};


/** @param {?proto.DeployContractTransaction|undefined} value */
proto.SignedTransaction.prototype.setDeployContract = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SignedTransaction.oneofGroups_[0], value);
};


proto.SignedTransaction.prototype.clearDeployContract = function() {
  this.setDeployContract(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasDeployContract = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional FunctionCallTransaction function_call = 4;
 * @return {?proto.FunctionCallTransaction}
 */
proto.SignedTransaction.prototype.getFunctionCall = function() {
  return /** @type{?proto.FunctionCallTransaction} */ (
    jspb.Message.getWrapperField(this, proto.FunctionCallTransaction, 4));
};


/** @param {?proto.FunctionCallTransaction|undefined} value */
proto.SignedTransaction.prototype.setFunctionCall = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.SignedTransaction.oneofGroups_[0], value);
};


proto.SignedTransaction.prototype.clearFunctionCall = function() {
  this.setFunctionCall(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasFunctionCall = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional SendMoneyTransaction send_money = 5;
 * @return {?proto.SendMoneyTransaction}
 */
proto.SignedTransaction.prototype.getSendMoney = function() {
  return /** @type{?proto.SendMoneyTransaction} */ (
    jspb.Message.getWrapperField(this, proto.SendMoneyTransaction, 5));
};


/** @param {?proto.SendMoneyTransaction|undefined} value */
proto.SignedTransaction.prototype.setSendMoney = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.SignedTransaction.oneofGroups_[0], value);
};


proto.SignedTransaction.prototype.clearSendMoney = function() {
  this.setSendMoney(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasSendMoney = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional StakeTransaction stake = 6;
 * @return {?proto.StakeTransaction}
 */
proto.SignedTransaction.prototype.getStake = function() {
  return /** @type{?proto.StakeTransaction} */ (
    jspb.Message.getWrapperField(this, proto.StakeTransaction, 6));
};


/** @param {?proto.StakeTransaction|undefined} value */
proto.SignedTransaction.prototype.setStake = function(value) {
  jspb.Message.setOneofWrapperField(this, 6, proto.SignedTransaction.oneofGroups_[0], value);
};


proto.SignedTransaction.prototype.clearStake = function() {
  this.setStake(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasStake = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional SwapKeyTransaction swap_key = 7;
 * @return {?proto.SwapKeyTransaction}
 */
proto.SignedTransaction.prototype.getSwapKey = function() {
  return /** @type{?proto.SwapKeyTransaction} */ (
    jspb.Message.getWrapperField(this, proto.SwapKeyTransaction, 7));
};


/** @param {?proto.SwapKeyTransaction|undefined} value */
proto.SignedTransaction.prototype.setSwapKey = function(value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.SignedTransaction.oneofGroups_[0], value);
};


proto.SignedTransaction.prototype.clearSwapKey = function() {
  this.setSwapKey(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasSwapKey = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional AddKeyTransaction add_key = 8;
 * @return {?proto.AddKeyTransaction}
 */
proto.SignedTransaction.prototype.getAddKey = function() {
  return /** @type{?proto.AddKeyTransaction} */ (
    jspb.Message.getWrapperField(this, proto.AddKeyTransaction, 8));
};


/** @param {?proto.AddKeyTransaction|undefined} value */
proto.SignedTransaction.prototype.setAddKey = function(value) {
  jspb.Message.setOneofWrapperField(this, 8, proto.SignedTransaction.oneofGroups_[0], value);
};


proto.SignedTransaction.prototype.clearAddKey = function() {
  this.setAddKey(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasAddKey = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional DeleteKeyTransaction delete_key = 9;
 * @return {?proto.DeleteKeyTransaction}
 */
proto.SignedTransaction.prototype.getDeleteKey = function() {
  return /** @type{?proto.DeleteKeyTransaction} */ (
    jspb.Message.getWrapperField(this, proto.DeleteKeyTransaction, 9));
};


/** @param {?proto.DeleteKeyTransaction|undefined} value */
proto.SignedTransaction.prototype.setDeleteKey = function(value) {
  jspb.Message.setOneofWrapperField(this, 9, proto.SignedTransaction.oneofGroups_[0], value);
};


proto.SignedTransaction.prototype.clearDeleteKey = function() {
  this.setDeleteKey(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedTransaction.prototype.hasDeleteKey = function() {
  return jspb.Message.getField(this, 9) != null;
};


goog.object.extend(exports, proto);
