// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://raw.githubusercontent.com' | (string & {});
};

/**
 * Access key provides limited access to an account. Each access key belongs to some account and
 * is identified by a unique (within the account) public key. One account may have large number of
 * access keys. Access keys allow to act on behalf of the account by restricting transactions
 * that can be issued.
 * `account_id,public_key` is a key in the state
 */
export type AccessKey = {
    /**
     * Nonce for this access key, used for tx nonce generation. When access key is created, nonce
     * is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.
     * See <https://github.com/near/nearcore/issues/3779> for more details.
     */
    nonce: number;
    /**
     * Defines permissions for this access key.
     */
    permission: AccessKeyPermission;
};

/**
 * Describes the cost of creating an access key.
 */
export type AccessKeyCreationConfigView = {
    /**
     * Base cost of creating a full access access-key.
     */
    full_access_cost: Fee;
    /**
     * Base cost of creating an access-key restricted to specific functions.
     */
    function_call_cost: Fee;
    /**
     * Cost per byte of method_names of creating a restricted access-key.
     */
    function_call_cost_per_byte: Fee;
};

/**
 * Describes information about an access key including the public key.
 */
export type AccessKeyInfoView = {
    access_key: AccessKeyView;
    public_key: PublicKey;
};

/**
 * Lists access keys
 */
export type AccessKeyList = {
    keys: Array<AccessKeyInfoView>;
};

/**
 * Defines permissions for AccessKey
 */
export type AccessKeyPermission =
    | {
          FunctionCall: FunctionCallPermission;
      }
    | 'FullAccess';

/**
 * Describes the permission scope for an access key. Whether it is a function call or a full access key.
 */
export type AccessKeyPermissionView =
    | 'FullAccess'
    | {
          FunctionCall: {
              allowance?: NearToken | null;
              method_names: Array<string>;
              receiver_id: string;
          };
      };

/**
 * Describes access key permission scope and nonce.
 */
export type AccessKeyView = {
    nonce: number;
    permission: AccessKeyPermissionView;
};

/**
 * The structure describes configuration for creation of new accounts.
 */
export type AccountCreationConfigView = {
    /**
     * The minimum length of the top-level account ID that is allowed to be created by any account.
     */
    min_allowed_top_level_account_length?: number;
    /**
     * The account ID of the account registrar. This account ID allowed to create top-level
     * accounts of any valid length.
     */
    registrar_account_id?: AccountId;
};

/**
 * AccountData is a piece of global state that a validator
 * signs and broadcasts to the network.
 *
 * It is essentially the data that a validator wants to share with the network.
 * All the nodes in the network are collecting the account data
 * broadcasted by the validators.
 * Since the number of the validators is bounded and their
 * identity is known (and the maximal size of allowed AccountData is bounded)
 * the global state that is distributed in the form of AccountData is bounded
 * as well.
 * Find more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)
 */
export type AccountDataView = {
    /**
     * Account key of the validator signing this AccountData.
     */
    account_key: PublicKey;
    /**
     * ID of the node that handles the account key (aka validator key).
     */
    peer_id: PublicKey;
    /**
     * Proxy nodes that are directly connected to the validator node
     * (this list may include the validator node itself).
     * TIER1 nodes should connect to one of the proxies to sent TIER1
     * messages to the validator.
     */
    proxies: Array<Tier1ProxyView>;
    /**
     * UTC timestamp of when the AccountData has been signed.
     */
    timestamp: string;
};

/**
 * AccountId
 *
 * NEAR Account Identifier.
 *
 * This is a unique, syntactically valid, human-readable account identifier on the NEAR network.
 *
 * [See the crate-level docs for information about validation.](index.html#account-id-rules)
 *
 * Also see [Error kind precedence](AccountId#error-kind-precedence).
 *
 * ## Examples
 *
 * ```
 * use near_account_id::AccountId;
 *
 * let alice: AccountId = "alice.near".parse().unwrap();
 *
 * assert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f)
 * ```
 */
export type AccountId = string;

export type AccountIdValidityRulesVersion = number;

/**
 * Account info for validators
 */
export type AccountInfo = {
    account_id: AccountId;
    amount: NearToken;
    public_key: PublicKey;
};

/**
 * A view of the account
 */
export type AccountView = {
    amount: NearToken;
    code_hash: CryptoHash;
    global_contract_account_id?: AccountId | null;
    global_contract_hash?: CryptoHash | null;
    locked: NearToken;
    /**
     * TODO(2271): deprecated.
     */
    storage_paid_at?: number;
    storage_usage: number;
};

/**
 * Account ID with its public key.
 */
export type AccountWithPublicKey = {
    account_id: AccountId;
    public_key: PublicKey;
};

/**
 * Describes the cost of creating a specific action, `Action`. Includes all variants.
 */
export type ActionCreationConfigView = {
    /**
     * Base cost of adding a key.
     */
    add_key_cost?: AccessKeyCreationConfigView;
    /**
     * Base cost of creating an account.
     */
    create_account_cost?: Fee;
    /**
     * Base cost for processing a delegate action.
     *
     * This is on top of the costs for the actions inside the delegate action.
     */
    delegate_cost?: Fee;
    /**
     * Base cost of deleting an account.
     */
    delete_account_cost?: Fee;
    /**
     * Base cost of deleting a key.
     */
    delete_key_cost?: Fee;
    /**
     * Base cost of deploying a contract.
     */
    deploy_contract_cost?: Fee;
    /**
     * Cost per byte of deploying a contract.
     */
    deploy_contract_cost_per_byte?: Fee;
    /**
     * Base cost of calling a function.
     */
    function_call_cost?: Fee;
    /**
     * Cost per byte of method name and arguments of calling a function.
     */
    function_call_cost_per_byte?: Fee;
    /**
     * Base cost of staking.
     */
    stake_cost?: Fee;
    /**
     * Base cost of making a transfer.
     */
    transfer_cost?: Fee;
};

/**
 * An error happened during Action execution
 */
export type ActionError = {
    /**
     * Index of the failed action in the transaction.
     * Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`
     */
    index?: number | null;
    /**
     * The kind of ActionError happened
     */
    kind: ActionErrorKind;
};

export type ActionErrorKind =
    | {
          AccountAlreadyExists: {
              account_id: AccountId;
          };
      }
    | {
          AccountDoesNotExist: {
              account_id: AccountId;
          };
      }
    | {
          CreateAccountOnlyByRegistrar: {
              account_id: AccountId;
              predecessor_id: AccountId;
              registrar_account_id: AccountId;
          };
      }
    | {
          CreateAccountNotAllowed: {
              account_id: AccountId;
              predecessor_id: AccountId;
          };
      }
    | {
          ActorNoPermission: {
              account_id: AccountId;
              actor_id: AccountId;
          };
      }
    | {
          DeleteKeyDoesNotExist: {
              account_id: AccountId;
              public_key: PublicKey;
          };
      }
    | {
          AddKeyAlreadyExists: {
              account_id: AccountId;
              public_key: PublicKey;
          };
      }
    | {
          DeleteAccountStaking: {
              account_id: AccountId;
          };
      }
    | {
          LackBalanceForState: {
              /**
               * An account which needs balance
               */
              account_id: AccountId;
              /**
               * Balance required to complete an action.
               */
              amount: NearToken;
          };
      }
    | {
          TriesToUnstake: {
              account_id: AccountId;
          };
      }
    | {
          TriesToStake: {
              account_id: AccountId;
              balance: NearToken;
              locked: NearToken;
              stake: NearToken;
          };
      }
    | {
          InsufficientStake: {
              account_id: AccountId;
              minimum_stake: NearToken;
              stake: NearToken;
          };
      }
    | {
          FunctionCallError: FunctionCallError;
      }
    | {
          NewReceiptValidationError: ReceiptValidationError;
      }
    | {
          OnlyImplicitAccountCreationAllowed: {
              account_id: AccountId;
          };
      }
    | {
          DeleteAccountWithLargeState: {
              account_id: AccountId;
          };
      }
    | 'DelegateActionInvalidSignature'
    | {
          DelegateActionSenderDoesNotMatchTxReceiver: {
              receiver_id: AccountId;
              sender_id: AccountId;
          };
      }
    | 'DelegateActionExpired'
    | {
          DelegateActionAccessKeyError: InvalidAccessKeyError;
      }
    | {
          DelegateActionInvalidNonce: {
              ak_nonce: number;
              delegate_nonce: number;
          };
      }
    | {
          DelegateActionNonceTooLarge: {
              delegate_nonce: number;
              upper_bound: number;
          };
      }
    | {
          GlobalContractDoesNotExist: {
              identifier: GlobalContractIdentifier;
          };
      }
    | {
          GasKeyDoesNotExist: {
              account_id: AccountId;
              public_key: PublicKey;
          };
      }
    | {
          GasKeyAlreadyExists: {
              account_id: AccountId;
              public_key: PublicKey;
          };
      };

export type ActionView =
    | 'CreateAccount'
    | {
          DeployContract: {
              code: string;
          };
      }
    | {
          FunctionCall: {
              args: FunctionArgs;
              deposit: NearToken;
              gas: NearGas;
              method_name: string;
          };
      }
    | {
          Transfer: {
              deposit: NearToken;
          };
      }
    | {
          Stake: {
              public_key: PublicKey;
              stake: NearToken;
          };
      }
    | {
          AddKey: {
              access_key: AccessKeyView;
              public_key: PublicKey;
          };
      }
    | {
          DeleteKey: {
              public_key: PublicKey;
          };
      }
    | {
          DeleteAccount: {
              beneficiary_id: AccountId;
          };
      }
    | {
          Delegate: {
              delegate_action: DelegateAction;
              signature: Signature;
          };
      }
    | {
          DeployGlobalContract: {
              code: string;
          };
      }
    | {
          DeployGlobalContractByAccountId: {
              code: string;
          };
      }
    | {
          UseGlobalContract: {
              code_hash: CryptoHash;
          };
      }
    | {
          UseGlobalContractByAccountId: {
              account_id: AccountId;
          };
      }
    | {
          DeterministicStateInit: {
              code: GlobalContractIdentifierView;
              data: {
                  [key: string]: string;
              };
              deposit: NearToken;
          };
      }
    | {
          AddGasKey: {
              num_nonces: number;
              permission: AccessKeyPermissionView;
              public_key: PublicKey;
          };
      }
    | {
          DeleteGasKey: {
              public_key: PublicKey;
          };
      }
    | {
          TransferToGasKey: {
              amount: NearToken;
              public_key: PublicKey;
          };
      };

/**
 * Describes the error for validating a list of actions.
 */
export type ActionsValidationError =
    | 'DeleteActionMustBeFinal'
    | {
          TotalPrepaidGasExceeded: {
              limit: NearGas;
              total_prepaid_gas: NearGas;
          };
      }
    | {
          TotalNumberOfActionsExceeded: {
              limit: number;
              total_number_of_actions: number;
          };
      }
    | {
          AddKeyMethodNamesNumberOfBytesExceeded: {
              limit: number;
              total_number_of_bytes: number;
          };
      }
    | {
          AddKeyMethodNameLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | 'IntegerOverflow'
    | {
          InvalidAccountId: {
              account_id: string;
          };
      }
    | {
          ContractSizeExceeded: {
              limit: number;
              size: number;
          };
      }
    | {
          FunctionCallMethodNameLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          FunctionCallArgumentsLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          UnsuitableStakingKey: {
              public_key: PublicKey;
          };
      }
    | 'FunctionCallZeroAttachedGas'
    | 'DelegateActionMustBeOnlyOne'
    | {
          UnsupportedProtocolFeature: {
              protocol_feature: string;
              version: number;
          };
      }
    | {
          InvalidDeterministicStateInitReceiver: {
              derived_id: AccountId;
              receiver_id: AccountId;
          };
      }
    | {
          DeterministicStateInitKeyLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          DeterministicStateInitValueLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          GasKeyPermissionInvalid: {
              permission: AccessKeyPermission;
          };
      }
    | {
          GasKeyTooManyNoncesRequested: {
              limit: number;
              requested_nonces: number;
          };
      };

export type AddGasKeyAction = {
    num_nonces: number;
    permission: AccessKeyPermission;
    public_key: PublicKey;
};

/**
 * An action that adds key with public key associated
 */
export type AddKeyAction = {
    /**
     * An access key with the permission
     */
    access_key: AccessKey;
    /**
     * A public key which will be associated with an access_key
     */
    public_key: PublicKey;
};

/**
 * `BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.
 * When a shard wants to send a lot of receipts to another shard, it needs to create a request and wait
 * for a bandwidth grant from the bandwidth scheduler.
 */
export type BandwidthRequest = {
    /**
     * Bitmap which describes what values of bandwidth are requested.
     */
    requested_values_bitmap: BandwidthRequestBitmap;
    /**
     * Requesting bandwidth to this shard.
     */
    to_shard: number;
};

/**
 * Bitmap which describes which values from the predefined list are being requested.
 * The nth bit is set to 1 when the nth value from the list is being requested.
 */
export type BandwidthRequestBitmap = {
    data: [number, number, number, number, number];
};

/**
 * A list of shard's bandwidth requests.
 * Describes how much the shard would like to send to other shards.
 */
export type BandwidthRequests = {
    V1: BandwidthRequestsV1;
};

/**
 * Version 1 of [`BandwidthRequest`].
 */
export type BandwidthRequestsV1 = {
    requests: Array<BandwidthRequest>;
};

/**
 * A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).
 */
export type BlockHeaderInnerLiteView = {
    /**
     * The merkle root of all the block hashes
     */
    block_merkle_root: CryptoHash;
    /**
     * The epoch to which the block that is the current known head belongs
     */
    epoch_id: CryptoHash;
    height: number;
    /**
     * The hash of the block producers set for the next epoch
     */
    next_bp_hash: CryptoHash;
    /**
     * The epoch that will follow the current epoch
     */
    next_epoch_id: CryptoHash;
    outcome_root: CryptoHash;
    prev_state_root: CryptoHash;
    /**
     * Legacy json number. Should not be used.
     */
    timestamp: number;
    timestamp_nanosec: string;
};

/**
 * Contains main info about the block.
 */
export type BlockHeaderView = {
    approvals: Array<Signature | null>;
    block_body_hash?: CryptoHash | null;
    block_merkle_root: CryptoHash;
    block_ordinal?: number | null;
    challenges_result: Array<SlashedValidator>;
    challenges_root: CryptoHash;
    chunk_endorsements?: Array<Array<number>> | null;
    chunk_headers_root: CryptoHash;
    chunk_mask: Array<boolean>;
    chunk_receipts_root: CryptoHash;
    chunk_tx_root: CryptoHash;
    chunks_included: number;
    epoch_id: CryptoHash;
    epoch_sync_data_hash?: CryptoHash | null;
    gas_price: NearToken;
    hash: CryptoHash;
    height: number;
    last_ds_final_block: CryptoHash;
    last_final_block: CryptoHash;
    latest_protocol_version: number;
    next_bp_hash: CryptoHash;
    next_epoch_id: CryptoHash;
    outcome_root: CryptoHash;
    /**
     * The hash of the previous Block
     */
    prev_hash: CryptoHash;
    prev_height?: number | null;
    prev_state_root: CryptoHash;
    random_value: CryptoHash;
    /**
     * TODO(2271): deprecated.
     */
    rent_paid?: NearToken;
    /**
     * Signature of the block producer.
     */
    signature: Signature;
    /**
     * Legacy json number. Should not be used.
     */
    timestamp: number;
    timestamp_nanosec: string;
    total_supply: NearToken;
    validator_proposals: Array<ValidatorStakeView>;
    /**
     * TODO(2271): deprecated.
     */
    validator_reward?: NearToken;
};

export type BlockId = number | CryptoHash;

export type BlockReference =
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      };

/**
 * Height and hash of a block
 */
export type BlockStatusView = {
    hash: CryptoHash;
    height: number;
};

/**
 * A result returned by contract method
 */
export type CallResult = {
    logs: Array<string>;
    result: Array<number>;
};

/**
 * Status of the [catchup](https://near.github.io/nearcore/architecture/how/sync.html#catchup) process
 */
export type CatchupStatusView = {
    blocks_to_catchup: Array<BlockStatusView>;
    shard_sync_status: {
        [key: string]: never;
    };
    sync_block_hash: CryptoHash;
    sync_block_height: number;
};

/**
 * Config for the Chunk Distribution Network feature.
 * This allows nodes to push and pull chunks from a central stream.
 * The two benefits of this approach are: (1) less request/response traffic
 * on the peer-to-peer network and (2) lower latency for RPC nodes indexing the chain.
 */
export type ChunkDistributionNetworkConfig = {
    enabled?: boolean;
    uris?: ChunkDistributionUris;
};

/**
 * URIs for the Chunk Distribution Network feature.
 */
export type ChunkDistributionUris = {
    /**
     * URI for pulling chunks from the stream.
     */
    get?: string;
    /**
     * URI for publishing chunks to the stream.
     */
    set?: string;
};

export type ChunkHash = CryptoHash;

/**
 * Contains main info about the chunk.
 */
export type ChunkHeaderView = {
    balance_burnt: NearToken;
    bandwidth_requests?: BandwidthRequests | null;
    chunk_hash: CryptoHash;
    congestion_info?: CongestionInfoView | null;
    encoded_length: number;
    encoded_merkle_root: CryptoHash;
    gas_limit: NearGas;
    gas_used: NearGas;
    height_created: number;
    height_included: number;
    outcome_root: CryptoHash;
    outgoing_receipts_root: CryptoHash;
    prev_block_hash: CryptoHash;
    prev_state_root: CryptoHash;
    /**
     * TODO(2271): deprecated.
     */
    rent_paid?: NearToken;
    shard_id: ShardId;
    signature: Signature;
    tx_root: CryptoHash;
    validator_proposals: Array<ValidatorStakeView>;
    /**
     * TODO(2271): deprecated.
     */
    validator_reward?: NearToken;
};

/**
 * Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and
 * writes chunk-related data based on the tracked shards. This config also controls additional archival
 * behavior such as block data and polling interval.
 */
export type CloudArchivalWriterConfig = {
    /**
     * Determines whether block-related data should be written to cloud storage.
     */
    archive_block_data?: boolean;
    /**
     * Interval at which the system checks for new blocks or chunks to archive.
     */
    polling_interval?: DurationAsStdSchemaProvider;
};

export type CompilationError =
    | {
          CodeDoesNotExist: {
              account_id: AccountId;
          };
      }
    | {
          PrepareError: PrepareError;
      }
    | {
          WasmerCompileError: {
              msg: string;
          };
      };

/**
 * The configuration for congestion control. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)
 */
export type CongestionControlConfigView = {
    /**
     * How much gas the chosen allowed shard can send to a 100% congested shard.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    allowed_shard_outgoing_gas?: NearGas;
    /**
     * How much gas in delayed receipts of a shard is 100% incoming congestion.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    max_congestion_incoming_gas?: NearGas;
    /**
     * How much memory space of all delayed and buffered receipts in a shard is
     * considered 100% congested.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    max_congestion_memory_consumption?: number;
    /**
     * How many missed chunks in a row in a shard is considered 100% congested.
     */
    max_congestion_missed_chunks?: number;
    /**
     * How much gas in outgoing buffered receipts of a shard is 100% congested.
     *
     * Outgoing congestion contributes to overall congestion, which reduces how
     * much other shards are allowed to forward to this shard.
     */
    max_congestion_outgoing_gas?: NearGas;
    /**
     * The maximum amount of gas attached to receipts a shard can forward to
     * another shard per chunk.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    max_outgoing_gas?: NearGas;
    /**
     * The maximum amount of gas in a chunk spent on converting new transactions to
     * receipts.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    max_tx_gas?: NearGas;
    /**
     * The minimum gas each shard can send to a shard that is not fully congested.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    min_outgoing_gas?: NearGas;
    /**
     * The minimum amount of gas in a chunk spent on converting new transactions
     * to receipts, as long as the receiving shard is not congested.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    min_tx_gas?: NearGas;
    /**
     * Large size limit for outgoing receipts to a shard, used when it's safe
     * to send a lot of receipts without making the state witness too large.
     * It limits the total sum of outgoing receipts, not individual receipts.
     */
    outgoing_receipts_big_size_limit?: number;
    /**
     * The standard size limit for outgoing receipts aimed at a single shard.
     * This limit is pretty small to keep the size of source_receipt_proofs under control.
     * It limits the total sum of outgoing receipts, not individual receipts.
     */
    outgoing_receipts_usual_size_limit?: number;
    /**
     * How much congestion a shard can tolerate before it stops all shards from
     * accepting new transactions with the receiver set to the congested shard.
     */
    reject_tx_congestion_threshold?: number;
};

/**
 * Stores the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)
 */
export type CongestionInfoView = {
    allowed_shard: number;
    buffered_receipts_gas: string;
    delayed_receipts_gas: string;
    receipt_bytes: number;
};

/**
 * A view of the contract code.
 */
export type ContractCodeView = {
    code_base64: string;
    hash: CryptoHash;
};

/**
 * Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).
 */
export type CostGasUsed = {
    cost: string;
    /**
     * Either ACTION_COST or WASM_HOST_COST.
     */
    cost_category: string;
    gas_used: string;
};

/**
 * Create account action
 */
export type CreateAccountAction = {
    [key: string]: unknown;
};

export type CryptoHash = string;

/**
 * Describes information about the current epoch validator
 */
export type CurrentEpochValidatorInfo = {
    account_id: AccountId;
    is_slashed: boolean;
    num_expected_blocks: number;
    num_expected_chunks?: number;
    /**
     * Number of chunks this validator was expected to produce in each shard.
     * Each entry in the array corresponds to the shard in the `shards_produced` array.
     */
    num_expected_chunks_per_shard?: Array<number>;
    num_expected_endorsements?: number;
    /**
     * Number of chunks this validator was expected to validate and endorse in each shard.
     * Each entry in the array corresponds to the shard in the `shards_endorsed` array.
     */
    num_expected_endorsements_per_shard?: Array<number>;
    num_produced_blocks: number;
    num_produced_chunks?: number;
    num_produced_chunks_per_shard?: Array<number>;
    num_produced_endorsements?: number;
    num_produced_endorsements_per_shard?: Array<number>;
    public_key: PublicKey;
    /**
     * Shards this validator is assigned to as chunk producer in the current epoch.
     */
    shards: Array<ShardId>;
    /**
     * Shards this validator is assigned to as chunk validator in the current epoch.
     */
    shards_endorsed?: Array<ShardId>;
    stake: NearToken;
};

/**
 * The fees settings for a data receipt creation
 */
export type DataReceiptCreationConfigView = {
    /**
     * Base cost of creating a data receipt.
     * Both `send` and `exec` costs are burned when a new receipt has input dependencies. The gas
     * is charged for each input dependency. The dependencies are specified when a receipt is
     * created using `promise_then` and `promise_batch_then`.
     * NOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.
     * Even if the last action is not a function call (in case of success it will return empty
     * value).
     */
    base_cost?: Fee;
    /**
     * Additional cost per byte sent.
     * Both `send` and `exec` costs are burned when a function call finishes execution and returns
     * `N` bytes of data to every output dependency. For each output dependency the cost is
     * `(send(sir) + exec()) * N`.
     */
    cost_per_byte?: Fee;
};

export type DataReceiverView = {
    data_id: CryptoHash;
    receiver_id: AccountId;
};

/**
 * This action allows to execute the inner actions behalf of the defined sender.
 */
export type DelegateAction = {
    /**
     * List of actions to be executed.
     *
     * With the meta transactions MVP defined in NEP-366, nested
     * DelegateActions are not allowed. A separate type is used to enforce it.
     */
    actions: Array<NonDelegateAction>;
    /**
     * The maximal height of the block in the blockchain below which the given DelegateAction is valid.
     */
    max_block_height: number;
    /**
     * Nonce to ensure that the same delegate action is not sent twice by a
     * relayer and should match for given account's `public_key`.
     * After this action is processed it will increment.
     */
    nonce: number;
    /**
     * Public key used to sign this delegated action.
     */
    public_key: PublicKey;
    /**
     * Receiver of the delegated actions.
     */
    receiver_id: AccountId;
    /**
     * Signer of the delegated actions
     */
    sender_id: AccountId;
};

export type DeleteAccountAction = {
    beneficiary_id: AccountId;
};

export type DeleteGasKeyAction = {
    public_key: PublicKey;
};

export type DeleteKeyAction = {
    /**
     * A public key associated with the access_key to be deleted.
     */
    public_key: PublicKey;
};

/**
 * Deploy contract action
 */
export type DeployContractAction = {
    /**
     * WebAssembly binary
     */
    code: string;
};

/**
 * Deploy global contract action
 */
export type DeployGlobalContractAction = {
    /**
     * WebAssembly binary
     */
    code: string;
    deploy_mode: GlobalContractDeployMode;
};

export type DetailedDebugStatus = {
    block_production_delay_millis: number;
    catchup_status: Array<CatchupStatusView>;
    current_head_status: BlockStatusView;
    current_header_head_status: BlockStatusView;
    network_info: NetworkInfoView;
    sync_status: string;
};

export type DeterministicAccountStateInit = {
    V1: DeterministicAccountStateInitV1;
};

export type DeterministicAccountStateInitV1 = {
    code: GlobalContractIdentifier;
    data: {
        [key: string]: string;
    };
};

export type DeterministicStateInitAction = {
    deposit: NearToken;
    state_init: DeterministicAccountStateInit;
};

export const Direction = { LEFT: 'Left', RIGHT: 'Right' } as const;

export type Direction = (typeof Direction)[keyof typeof Direction];

/**
 * Configures how to dump state to external storage.
 */
export type DumpConfig = {
    /**
     * Location of a json file with credentials allowing access to the bucket.
     */
    credentials_file?: string | null;
    /**
     * How often to check if a new epoch has started.
     * Feel free to set to `None`, defaults are sensible.
     */
    iteration_delay?: DurationAsStdSchemaProvider | null;
    /**
     * Specifies where to write the obtained state parts.
     */
    location?: ExternalStorageLocation;
    /**
     * Use in case a node that dumps state to the external storage
     * gets in trouble.
     */
    restart_dump_for_shards?: Array<ShardId> | null;
};

export type DurationAsStdSchemaProvider = {
    nanos: number;
    secs: number;
};

/**
 * Configuration for dynamic resharding feature
 */
export type DynamicReshardingConfigView = {
    /**
     * Maximum number of shards in the network.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    max_number_of_shards: number;
    /**
     * Memory threshold over which a shard is marked for a split.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    memory_usage_threshold: number;
    /**
     * Minimum memory usage of a child shard.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    min_child_memory_usage: number;
    /**
     * Minimum number of epochs until next resharding can be scheduled.
     *
     * See [`CongestionControlConfig`] for more details.
     */
    min_epochs_between_resharding: number;
};

/**
 * Epoch identifier -- wrapped hash, to make it easier to distinguish.
 * EpochId of epoch T is the hash of last block in T-2
 * EpochId of first two epochs is 0
 */
export type EpochId = CryptoHash;

export type EpochSyncConfig = {
    /**
     * If true, even if the node started from genesis, it will not perform epoch sync.
     * There should be no reason to set this flag in production, because on both mainnet
     * and testnet it would be infeasible to catch up from genesis without epoch sync.
     */
    disable_epoch_sync_for_bootstrapping?: boolean;
    /**
     * This serves as two purposes: (1) the node will not epoch sync and instead resort to
     * header sync, if the genesis block is within this many blocks from the current block;
     * (2) the node will reject an epoch sync proof if the provided proof is for an epoch
     * that is more than this many blocks behind the current block.
     */
    epoch_sync_horizon?: number;
    /**
     * If true, the node will ignore epoch sync requests from the network. It is strongly
     * recommended not to set this flag, because it will prevent other nodes from
     * bootstrapping. This flag is only included as a kill-switch and may be removed in a
     * future release. Please note that epoch sync requests are heavily rate limited and
     * cached, and therefore should not affect the performance of the node or introduce
     * any non-negligible increase in network traffic.
     */
    ignore_epoch_sync_network_requests?: boolean;
    /**
     * Timeout for epoch sync requests. The node will continue retrying indefinitely even
     * if this timeout is exceeded.
     */
    timeout_for_epoch_sync?: DurationAsStdSchemaProvider;
};

export type ErrorWrapperForGenesisConfigError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: GenesisConfigError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcBlockError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcBlockError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcCallFunctionError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcCallFunctionError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcChunkError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcChunkError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcClientConfigError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcClientConfigError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcGasPriceError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcGasPriceError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcLightClientNextBlockError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcLightClientNextBlockError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcLightClientProofError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcLightClientProofError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcMaintenanceWindowsError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcMaintenanceWindowsError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcNetworkInfoError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcNetworkInfoError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcProtocolConfigError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcProtocolConfigError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcQueryError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcQueryError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcReceiptError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcReceiptError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcSplitStorageInfoError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcSplitStorageInfoError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcStateChangesError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcStateChangesError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcStatusError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcStatusError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcTransactionError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcTransactionError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcValidatorError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcValidatorError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcViewAccessKeyError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcViewAccessKeyError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcViewAccessKeyListError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcViewAccessKeyListError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcViewAccountError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcViewAccountError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcViewCodeError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcViewCodeError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcViewGasKeyError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcViewGasKeyError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcViewGasKeyListError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcViewGasKeyListError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ErrorWrapperForRpcViewStateError =
    | {
          cause: RpcRequestValidationErrorKind;
          name: 'REQUEST_VALIDATION_ERROR';
      }
    | {
          cause: RpcViewStateError;
          name: 'HANDLER_ERROR';
      }
    | {
          cause: InternalError;
          name: 'INTERNAL_ERROR';
      };

export type ExecutionMetadataView = {
    gas_profile?: Array<CostGasUsed> | null;
    version: number;
};

export type ExecutionOutcomeView = {
    /**
     * The id of the account on which the execution happens. For transaction this is signer_id,
     * for receipt this is receiver_id.
     */
    executor_id: AccountId;
    /**
     * The amount of the gas burnt by the given transaction or receipt.
     */
    gas_burnt: NearGas;
    /**
     * Logs from this transaction or receipt.
     */
    logs: Array<string>;
    /**
     * Execution metadata, versioned
     */
    metadata?: ExecutionMetadataView;
    /**
     * Receipt IDs generated by this transaction or receipt.
     */
    receipt_ids: Array<CryptoHash>;
    /**
     * Execution status. Contains the result in case of successful execution.
     */
    status: ExecutionStatusView;
    /**
     * The amount of tokens burnt corresponding to the burnt gas amount.
     * This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
     * the prepaid gas price might be lower than the actual gas price and it creates a deficit.
     * `tokens_burnt` also contains the penalty subtracted from refunds, while
     * `gas_burnt` only contains the gas that we actually burn for the execution.
     */
    tokens_burnt: NearToken;
};

export type ExecutionOutcomeWithIdView = {
    block_hash: CryptoHash;
    id: CryptoHash;
    outcome: ExecutionOutcomeView;
    proof: Array<MerklePathItem>;
};

export type ExecutionStatusView =
    | 'Unknown'
    | {
          Failure: TxExecutionError;
      }
    | {
          SuccessValue: string;
      }
    | {
          SuccessReceiptId: CryptoHash;
      };

/**
 * Typed view of ExtCostsConfig to preserve JSON output field names in protocol
 * config RPC output.
 */
export type ExtCostsConfigView = {
    /**
     * Base cost for multiexp
     */
    alt_bn128_g1_multiexp_base?: NearGas;
    /**
     * Per element cost for multiexp
     */
    alt_bn128_g1_multiexp_element?: NearGas;
    /**
     * Base cost for sum
     */
    alt_bn128_g1_sum_base?: NearGas;
    /**
     * Per element cost for sum
     */
    alt_bn128_g1_sum_element?: NearGas;
    /**
     * Base cost for pairing check
     */
    alt_bn128_pairing_check_base?: NearGas;
    /**
     * Per element cost for pairing check
     */
    alt_bn128_pairing_check_element?: NearGas;
    /**
     * Base cost for calling a host function.
     */
    base?: NearGas;
    bls12381_g1_multiexp_base?: NearGas;
    bls12381_g1_multiexp_element?: NearGas;
    bls12381_g2_multiexp_base?: NearGas;
    bls12381_g2_multiexp_element?: NearGas;
    bls12381_map_fp2_to_g2_base?: NearGas;
    bls12381_map_fp2_to_g2_element?: NearGas;
    bls12381_map_fp_to_g1_base?: NearGas;
    bls12381_map_fp_to_g1_element?: NearGas;
    bls12381_p1_decompress_base?: NearGas;
    bls12381_p1_decompress_element?: NearGas;
    bls12381_p1_sum_base?: NearGas;
    bls12381_p1_sum_element?: NearGas;
    bls12381_p2_decompress_base?: NearGas;
    bls12381_p2_decompress_element?: NearGas;
    bls12381_p2_sum_base?: NearGas;
    bls12381_p2_sum_element?: NearGas;
    bls12381_pairing_base?: NearGas;
    bls12381_pairing_element?: NearGas;
    contract_compile_base?: NearGas;
    contract_compile_bytes?: NearGas;
    /**
     * Base cost of loading a pre-compiled contract
     */
    contract_loading_base?: NearGas;
    /**
     * Cost per byte of loading a pre-compiled contract
     */
    contract_loading_bytes?: NearGas;
    /**
     * Cost of calling ecrecover
     */
    ecrecover_base?: NearGas;
    /**
     * Cost of getting ed25519 base
     */
    ed25519_verify_base?: NearGas;
    /**
     * Cost of getting ed25519 per byte
     */
    ed25519_verify_byte?: NearGas;
    /**
     * Cost of getting sha256 base
     */
    keccak256_base?: NearGas;
    /**
     * Cost of getting sha256 per byte
     */
    keccak256_byte?: NearGas;
    /**
     * Cost of getting sha256 base
     */
    keccak512_base?: NearGas;
    /**
     * Cost of getting sha256 per byte
     */
    keccak512_byte?: NearGas;
    /**
     * Cost for calling logging.
     */
    log_base?: NearGas;
    /**
     * Cost for logging per byte
     */
    log_byte?: NearGas;
    /**
     * Cost for calling `promise_and`
     */
    promise_and_base?: NearGas;
    /**
     * Cost for calling `promise_and` for each promise
     */
    promise_and_per_promise?: NearGas;
    /**
     * Cost for calling `promise_return`
     */
    promise_return?: NearGas;
    /**
     * Cost for reading trie node from memory
     */
    read_cached_trie_node?: NearGas;
    /**
     * Base cost for guest memory read
     */
    read_memory_base?: NearGas;
    /**
     * Cost for guest memory read
     */
    read_memory_byte?: NearGas;
    /**
     * Base cost for reading from register
     */
    read_register_base?: NearGas;
    /**
     * Cost for reading byte from register
     */
    read_register_byte?: NearGas;
    /**
     * Cost of getting ripemd160 base
     */
    ripemd160_base?: NearGas;
    /**
     * Cost of getting ripemd160 per message block
     */
    ripemd160_block?: NearGas;
    /**
     * Cost of getting sha256 base
     */
    sha256_base?: NearGas;
    /**
     * Cost of getting sha256 per byte
     */
    sha256_byte?: NearGas;
    /**
     * Storage trie check for key existence cost base
     */
    storage_has_key_base?: NearGas;
    /**
     * Storage trie check for key existence per key byte
     */
    storage_has_key_byte?: NearGas;
    /**
     * Create trie range iterator cost per byte of from key.
     */
    storage_iter_create_from_byte?: NearGas;
    /**
     * Create trie prefix iterator cost base
     */
    storage_iter_create_prefix_base?: NearGas;
    /**
     * Create trie prefix iterator cost per byte.
     */
    storage_iter_create_prefix_byte?: NearGas;
    /**
     * Create trie range iterator cost base
     */
    storage_iter_create_range_base?: NearGas;
    /**
     * Create trie range iterator cost per byte of to key.
     */
    storage_iter_create_to_byte?: NearGas;
    /**
     * Trie iterator per key base cost
     */
    storage_iter_next_base?: NearGas;
    /**
     * Trie iterator next key byte cost
     */
    storage_iter_next_key_byte?: NearGas;
    /**
     * Trie iterator next key byte cost
     */
    storage_iter_next_value_byte?: NearGas;
    /**
     * Storage trie read key overhead base cost, when doing large reads
     */
    storage_large_read_overhead_base?: NearGas;
    /**
     * Storage trie read key overhead  per-byte cost, when doing large reads
     */
    storage_large_read_overhead_byte?: NearGas;
    /**
     * Storage trie read key base cost
     */
    storage_read_base?: NearGas;
    /**
     * Storage trie read key per byte cost
     */
    storage_read_key_byte?: NearGas;
    /**
     * Storage trie read value cost per byte cost
     */
    storage_read_value_byte?: NearGas;
    /**
     * Remove key from trie base cost
     */
    storage_remove_base?: NearGas;
    /**
     * Remove key from trie per byte cost
     */
    storage_remove_key_byte?: NearGas;
    /**
     * Remove key from trie ret value byte cost
     */
    storage_remove_ret_value_byte?: NearGas;
    /**
     * Storage trie write key base cost
     */
    storage_write_base?: NearGas;
    /**
     * Storage trie write cost per byte of evicted value.
     */
    storage_write_evicted_byte?: NearGas;
    /**
     * Storage trie write key per byte cost
     */
    storage_write_key_byte?: NearGas;
    /**
     * Storage trie write value per byte cost
     */
    storage_write_value_byte?: NearGas;
    /**
     * Cost per reading trie node from DB
     */
    touching_trie_node?: NearGas;
    /**
     * Base cost of decoding utf16. It's used for `log_utf16`.
     */
    utf16_decoding_base?: NearGas;
    /**
     * Cost per byte of decoding utf16. It's used for `log_utf16`.
     */
    utf16_decoding_byte?: NearGas;
    /**
     * Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`.
     */
    utf8_decoding_base?: NearGas;
    /**
     * Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`.
     */
    utf8_decoding_byte?: NearGas;
    /**
     * Cost of calling `validator_stake`.
     */
    validator_stake_base?: NearGas;
    /**
     * Cost of calling `validator_total_stake`.
     */
    validator_total_stake_base?: NearGas;
    /**
     * Base cost for guest memory write
     */
    write_memory_base?: NearGas;
    /**
     * Cost for guest memory write per byte
     */
    write_memory_byte?: NearGas;
    /**
     * Base cost for writing into register
     */
    write_register_base?: NearGas;
    /**
     * Cost for writing byte into register
     */
    write_register_byte?: NearGas;
    /**
     * Base cost for creating a yield promise.
     */
    yield_create_base?: NearGas;
    /**
     * Per byte cost of arguments and method name.
     */
    yield_create_byte?: NearGas;
    /**
     * Base cost for resuming a yield receipt.
     */
    yield_resume_base?: NearGas;
    /**
     * Per byte cost of resume payload.
     */
    yield_resume_byte?: NearGas;
};

export type ExternalStorageConfig = {
    /**
     * The number of attempts the node will make to obtain a part from peers in
     * the network before it fetches from external storage.
     */
    external_storage_fallback_threshold?: number;
    /**
     * Location of state parts.
     */
    location?: ExternalStorageLocation;
    /**
     * When fetching state parts from external storage, throttle fetch requests
     * to this many concurrent requests.
     */
    num_concurrent_requests?: number;
    /**
     * During catchup, the node will use a different number of concurrent requests
     * to reduce the performance impact of state sync.
     */
    num_concurrent_requests_during_catchup?: number;
};

/**
 * Supported external storage backends and their minimal config.
 */
export type ExternalStorageLocation =
    | {
          S3: {
              /**
               * Location on S3.
               */
              bucket: string;
              /**
               * Data may only be available in certain locations.
               */
              region: string;
          };
      }
    | {
          Filesystem: {
              root_dir: string;
          };
      }
    | {
          GCS: {
              bucket: string;
          };
      };

/**
 * Costs associated with an object that can only be sent over the network (and executed
 * by the receiver).
 * NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.
 * And `execution` fee is burned when the item is being executed.
 */
export type Fee = {
    /**
     * Fee for executing the object.
     */
    execution: NearGas;
    /**
     * Fee for sending an object potentially across the shards.
     */
    send_not_sir: NearGas;
    /**
     * Fee for sending an object from the sender to itself, guaranteeing that it does not leave
     * the shard.
     */
    send_sir: NearGas;
};

/**
 * Execution outcome of the transaction and all the subsequent receipts.
 * Could be not finalized yet
 */
export type FinalExecutionOutcomeView = {
    /**
     * The execution outcome of receipts.
     */
    receipts_outcome: Array<ExecutionOutcomeWithIdView>;
    /**
     * Execution status defined by chain.rs:get_final_transaction_result
     * FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet
     * FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution
     * FinalExecutionStatus::Failure - the result of the first leaf receipt_id
     * FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id
     */
    status: FinalExecutionStatus;
    /**
     * Signed Transaction
     */
    transaction: SignedTransactionView;
    /**
     * The execution outcome of the signed transaction.
     */
    transaction_outcome: ExecutionOutcomeWithIdView;
};

/**
 * Final execution outcome of the transaction and all of subsequent the receipts. Also includes
 * the generated receipt.
 */
export type FinalExecutionOutcomeWithReceiptView = {
    /**
     * Receipts generated from the transaction
     */
    receipts: Array<ReceiptView>;
    /**
     * The execution outcome of receipts.
     */
    receipts_outcome: Array<ExecutionOutcomeWithIdView>;
    /**
     * Execution status defined by chain.rs:get_final_transaction_result
     * FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet
     * FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution
     * FinalExecutionStatus::Failure - the result of the first leaf receipt_id
     * FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id
     */
    status: FinalExecutionStatus;
    /**
     * Signed Transaction
     */
    transaction: SignedTransactionView;
    /**
     * The execution outcome of the signed transaction.
     */
    transaction_outcome: ExecutionOutcomeWithIdView;
};

export type FinalExecutionStatus =
    | 'NotStarted'
    | 'Started'
    | {
          Failure: TxExecutionError;
      }
    | {
          SuccessValue: string;
      };

/**
 * Different types of finality.
 */
export const Finality = {
    OPTIMISTIC: 'optimistic',
    NEAR_FINAL: 'near-final',
    FINAL: 'final',
} as const;

/**
 * Different types of finality.
 */
export type Finality = (typeof Finality)[keyof typeof Finality];

/**
 * This type is used to mark function arguments.
 *
 * NOTE: The main reason for this to exist (except the type-safety) is that the value is
 * transparently serialized and deserialized as a base64-encoded string when serde is used
 * (serde_json).
 */
export type FunctionArgs = string;

export type FunctionCallAction = {
    args: string;
    deposit: NearToken;
    gas: NearGas;
    method_name: string;
};

/**
 * Serializable version of `near-vm-runner::FunctionCallError`.
 *
 * Must never reorder/remove elements, can only add new variants at the end (but do that very
 * carefully). It describes stable serialization format, and only used by serialization logic.
 */
export type FunctionCallError =
    | 'WasmUnknownError'
    | '_EVMError'
    | {
          CompilationError: CompilationError;
      }
    | {
          LinkError: {
              msg: string;
          };
      }
    | {
          MethodResolveError: MethodResolveError;
      }
    | {
          WasmTrap: WasmTrap;
      }
    | {
          HostError: HostError;
      }
    | {
          ExecutionError: string;
      };

/**
 * Grants limited permission to make transactions with FunctionCallActions
 * The permission can limit the allowed balance to be spent on the prepaid gas.
 * It also restrict the account ID of the receiver for this function call.
 * It also can restrict the method name for the allowed function calls.
 */
export type FunctionCallPermission = {
    /**
     * Allowance is a balance limit to use by this access key to pay for function call gas and
     * transaction fees. When this access key is used, both account balance and the allowance is
     * decreased by the same value.
     * `None` means unlimited allowance.
     * NOTE: To change or increase the allowance, the old access key needs to be deleted and a new
     * access key should be created.
     */
    allowance?: NearToken | null;
    /**
     * A list of method names that can be used. The access key only allows transactions with the
     * function call of one of the given method names.
     * Empty list means any method name can be used.
     */
    method_names: Array<string>;
    /**
     * The access key only allows transactions with the given receiver's account id.
     */
    receiver_id: string;
};

/**
 * Configuration for garbage collection.
 */
export type GcConfig = {
    /**
     * Maximum number of blocks to garbage collect at every garbage collection
     * call.
     */
    gc_blocks_limit?: number;
    /**
     * Maximum number of height to go through at each garbage collection step
     * when cleaning forks during garbage collection.
     */
    gc_fork_clean_step?: number;
    /**
     * Number of epochs for which we keep store data.
     */
    gc_num_epochs_to_keep?: number;
    /**
     * How often gc should be run
     */
    gc_step_period?: DurationAsStdSchemaProvider;
};

/**
 * Gas key is like an access key, except it stores a balance separately, and transactions signed
 * with it deduct their cost from the gas key balance instead of the account balance.
 */
export type GasKey = {
    /**
     * The balance of the gas key.
     */
    balance: NearToken;
    /**
     * The number of nonces this gas key has.
     */
    num_nonces: number;
    /**
     * Defines the permissions for this gas key.
     * If this is a `FunctionCallPermission`, the allowance must be None (unlimited).
     */
    permission: AccessKeyPermission;
};

export type GasKeyInfoView = {
    gas_key: GasKeyView;
    public_key: PublicKey;
};

export type GasKeyList = {
    keys: Array<GasKeyInfoView>;
};

export type GasKeyView = {
    balance: NearToken;
    nonces: Array<number>;
    num_nonces: number;
    permission: AccessKeyPermissionView;
};

export type GenesisConfig = {
    /**
     * Expected number of hidden validators per shard.
     */
    avg_hidden_validator_seats_per_shard: Array<number>;
    /**
     * Threshold for kicking out block producers, between 0 and 100.
     */
    block_producer_kickout_threshold: number;
    /**
     * ID of the blockchain. This must be unique for every blockchain.
     * If your testnet blockchains do not have unique chain IDs, you will have a bad time.
     */
    chain_id: string;
    /**
     * Limits the number of shard changes in chunk producer assignments,
     * if algorithm is able to choose assignment with better balance of
     * number of chunk producers for shards.
     */
    chunk_producer_assignment_changes_limit?: number;
    /**
     * Threshold for kicking out chunk producers, between 0 and 100.
     */
    chunk_producer_kickout_threshold: number;
    /**
     * Threshold for kicking out nodes which are only chunk validators, between 0 and 100.
     */
    chunk_validator_only_kickout_threshold?: number;
    /**
     * Enable dynamic re-sharding.
     */
    dynamic_resharding: boolean;
    /**
     * Epoch length counted in block heights.
     */
    epoch_length: number;
    /**
     * Fishermen stake threshold.
     */
    fishermen_threshold: NearToken;
    /**
     * Initial gas limit.
     */
    gas_limit: NearGas;
    /**
     * Gas price adjustment rate
     */
    gas_price_adjustment_rate: [number, number];
    /**
     * Height of genesis block.
     */
    genesis_height: number;
    /**
     * Official time of blockchain start.
     */
    genesis_time: string;
    max_gas_price: NearToken;
    /**
     * Maximum inflation on the total supply every epoch.
     */
    max_inflation_rate: [number, number];
    /**
     * Max stake percentage of the validators we will kick out.
     */
    max_kickout_stake_perc?: number;
    /**
     * Minimum gas price. It is also the initial gas price.
     */
    min_gas_price: NearToken;
    /**
     * The minimum stake required for staking is last seat price divided by this number.
     */
    minimum_stake_divisor?: number;
    /**
     * The lowest ratio s/s_total any block producer can have.
     * See <https://github.com/near/NEPs/pull/167> for details
     */
    minimum_stake_ratio?: [number, number];
    /**
     * The minimum number of validators each shard must have
     */
    minimum_validators_per_shard?: number;
    /**
     * Number of block producer seats at genesis.
     */
    num_block_producer_seats: number;
    /**
     * Defines number of shards and number of block producer seats per each shard at genesis.
     * Note: not used with protocol_feature_chunk_only_producers -- replaced by minimum_validators_per_shard
     * Note: not used before as all block producers produce chunks for all shards
     */
    num_block_producer_seats_per_shard: Array<number>;
    /**
     * Expected number of blocks per year
     */
    num_blocks_per_year: number;
    /**
     * Deprecated.
     */
    num_chunk_only_producer_seats?: number;
    /**
     * Number of chunk producers.
     * Don't mess it up with chunk-only producers feature which is deprecated.
     */
    num_chunk_producer_seats?: number;
    num_chunk_validator_seats?: number;
    /**
     * Online maximum threshold above which validator gets full reward.
     */
    online_max_threshold?: [number, number];
    /**
     * Online minimum threshold below which validator doesn't receive reward.
     */
    online_min_threshold?: [number, number];
    /**
     * Protocol treasury rate
     */
    protocol_reward_rate: [number, number];
    /**
     * Protocol treasury account
     */
    protocol_treasury_account: AccountId;
    /**
     * Threshold of stake that needs to indicate that they ready for upgrade.
     */
    protocol_upgrade_stake_threshold?: [number, number];
    /**
     * Protocol version that this genesis works with.
     */
    protocol_version: number;
    /**
     * Layout information regarding how to split accounts to shards
     */
    shard_layout?: ShardLayout;
    /**
     * If true, shuffle the chunk producers across shards. In other words, if
     * the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents
     * the set of chunk producers for shard `i`, if this flag were true, the
     * shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.
     */
    shuffle_shard_assignment_for_chunk_producers?: boolean;
    /**
     * Number of target chunk validator mandates for each shard.
     */
    target_validator_mandates_per_shard?: number;
    /**
     * Total supply of tokens at genesis.
     */
    total_supply: NearToken;
    /**
     * Number of blocks for which a given transaction is valid
     */
    transaction_validity_period: number;
    /**
     * This is only for test purposes. We hard code some configs for mainnet and testnet
     * in AllEpochConfig, and we want to have a way to test that code path. This flag is for that.
     * If set to true, the node will use the same config override path as mainnet and testnet.
     */
    use_production_config?: boolean;
    /**
     * List of initial validators.
     */
    validators: Array<AccountInfo>;
};

export const GenesisConfigError = { NULL: null } as const;

export type GenesisConfigError = (typeof GenesisConfigError)[keyof typeof GenesisConfigError];

/**
 * GenesisConfigRequest
 */
export const GenesisConfigRequest = { NULL: null } as const;

/**
 * GenesisConfigRequest
 */
export type GenesisConfigRequest = (typeof GenesisConfigRequest)[keyof typeof GenesisConfigRequest];

export type GlobalContractDeployMode = 'CodeHash' | 'AccountId';

export type GlobalContractIdentifier =
    | {
          CodeHash: CryptoHash;
      }
    | {
          AccountId: AccountId;
      };

export type GlobalContractIdentifierView =
    | {
          hash: CryptoHash;
      }
    | {
          account_id: AccountId;
      };

export type HostError =
    | 'BadUTF16'
    | 'BadUTF8'
    | 'GasExceeded'
    | 'GasLimitExceeded'
    | 'BalanceExceeded'
    | 'EmptyMethodName'
    | {
          GuestPanic: {
              panic_msg: string;
          };
      }
    | 'IntegerOverflow'
    | {
          InvalidPromiseIndex: {
              promise_idx: number;
          };
      }
    | 'CannotAppendActionToJointPromise'
    | 'CannotReturnJointPromise'
    | {
          InvalidPromiseResultIndex: {
              result_idx: number;
          };
      }
    | {
          InvalidRegisterId: {
              register_id: number;
          };
      }
    | {
          IteratorWasInvalidated: {
              iterator_index: number;
          };
      }
    | 'MemoryAccessViolation'
    | {
          InvalidReceiptIndex: {
              receipt_index: number;
          };
      }
    | {
          InvalidIteratorIndex: {
              iterator_index: number;
          };
      }
    | 'InvalidAccountId'
    | 'InvalidMethodName'
    | 'InvalidPublicKey'
    | {
          ProhibitedInView: {
              method_name: string;
          };
      }
    | {
          NumberOfLogsExceeded: {
              limit: number;
          };
      }
    | {
          KeyLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          ValueLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          TotalLogLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          NumberPromisesExceeded: {
              limit: number;
              number_of_promises: number;
          };
      }
    | {
          NumberInputDataDependenciesExceeded: {
              limit: number;
              number_of_input_data_dependencies: number;
          };
      }
    | {
          ReturnedValueLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          ContractSizeExceeded: {
              limit: number;
              size: number;
          };
      }
    | {
          Deprecated: {
              method_name: string;
          };
      }
    | {
          ECRecoverError: {
              msg: string;
          };
      }
    | {
          AltBn128InvalidInput: {
              msg: string;
          };
      }
    | {
          Ed25519VerifyInvalidInput: {
              msg: string;
          };
      };

export type InternalError = {
    info: {
        error_message: string;
    };
    name: 'INTERNAL_ERROR';
};

export type InvalidAccessKeyError =
    | {
          AccessKeyNotFound: {
              account_id: AccountId;
              public_key: PublicKey;
          };
      }
    | {
          ReceiverMismatch: {
              ak_receiver: string;
              tx_receiver: AccountId;
          };
      }
    | {
          MethodNameMismatch: {
              method_name: string;
          };
      }
    | 'RequiresFullAccess'
    | {
          NotEnoughAllowance: {
              account_id: AccountId;
              allowance: NearToken;
              cost: NearToken;
              public_key: PublicKey;
          };
      }
    | 'DepositWithFunctionCall';

/**
 * An error happened during TX execution
 */
export type InvalidTxError =
    | {
          InvalidAccessKeyError: InvalidAccessKeyError;
      }
    | {
          InvalidSignerId: {
              signer_id: string;
          };
      }
    | {
          SignerDoesNotExist: {
              signer_id: AccountId;
          };
      }
    | {
          InvalidNonce: {
              ak_nonce: number;
              tx_nonce: number;
          };
      }
    | {
          NonceTooLarge: {
              tx_nonce: number;
              upper_bound: number;
          };
      }
    | {
          InvalidReceiverId: {
              receiver_id: string;
          };
      }
    | 'InvalidSignature'
    | {
          NotEnoughBalance: {
              balance: NearToken;
              cost: NearToken;
              signer_id: AccountId;
          };
      }
    | {
          LackBalanceForState: {
              /**
               * Required balance to cover the state.
               */
              amount: NearToken;
              /**
               * An account which doesn't have enough balance to cover storage.
               */
              signer_id: AccountId;
          };
      }
    | 'CostOverflow'
    | 'InvalidChain'
    | 'Expired'
    | {
          ActionsValidation: ActionsValidationError;
      }
    | {
          TransactionSizeExceeded: {
              limit: number;
              size: number;
          };
      }
    | 'InvalidTransactionVersion'
    | {
          StorageError: StorageError;
      }
    | {
          ShardCongested: {
              /**
               * A value between 0 (no congestion) and 1 (max congestion).
               */
              congestion_level: number;
              /**
               * The congested shard.
               */
              shard_id: number;
          };
      }
    | {
          ShardStuck: {
              /**
               * The number of blocks since the last included chunk of the shard.
               */
              missed_chunks: number;
              /**
               * The shard that fails making progress.
               */
              shard_id: number;
          };
      };

/**
 * JsonRpcRequest_for_EXPERIMENTAL_call_function
 */
export type JsonRpcRequestForExperimentalCallFunction = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_call_function';
    params: RpcCallFunctionRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_changes
 */
export type JsonRpcRequestForExperimentalChanges = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_changes';
    params: RpcStateChangesInBlockByTypeRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_changes_in_block
 */
export type JsonRpcRequestForExperimentalChangesInBlock = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_changes_in_block';
    params: RpcStateChangesInBlockRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_congestion_level
 */
export type JsonRpcRequestForExperimentalCongestionLevel = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_congestion_level';
    params: RpcCongestionLevelRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_genesis_config
 */
export type JsonRpcRequestForExperimentalGenesisConfig = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_genesis_config';
    params: GenesisConfigRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_light_client_block_proof
 */
export type JsonRpcRequestForExperimentalLightClientBlockProof = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_light_client_block_proof';
    params: RpcLightClientBlockProofRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_light_client_proof
 */
export type JsonRpcRequestForExperimentalLightClientProof = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_light_client_proof';
    params: RpcLightClientExecutionProofRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_maintenance_windows
 */
export type JsonRpcRequestForExperimentalMaintenanceWindows = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_maintenance_windows';
    params: RpcMaintenanceWindowsRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_protocol_config
 */
export type JsonRpcRequestForExperimentalProtocolConfig = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_protocol_config';
    params: RpcProtocolConfigRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_receipt
 */
export type JsonRpcRequestForExperimentalReceipt = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_receipt';
    params: RpcReceiptRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_split_storage_info
 */
export type JsonRpcRequestForExperimentalSplitStorageInfo = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_split_storage_info';
    params: RpcSplitStorageInfoRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_tx_status
 */
export type JsonRpcRequestForExperimentalTxStatus = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_tx_status';
    params: RpcTransactionStatusRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_validators_ordered
 */
export type JsonRpcRequestForExperimentalValidatorsOrdered = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_validators_ordered';
    params: RpcValidatorsOrderedRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_view_access_key
 */
export type JsonRpcRequestForExperimentalViewAccessKey = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_view_access_key';
    params: RpcViewAccessKeyRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_view_access_key_list
 */
export type JsonRpcRequestForExperimentalViewAccessKeyList = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_view_access_key_list';
    params: RpcViewAccessKeyListRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_view_account
 */
export type JsonRpcRequestForExperimentalViewAccount = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_view_account';
    params: RpcViewAccountRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_view_code
 */
export type JsonRpcRequestForExperimentalViewCode = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_view_code';
    params: RpcViewCodeRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_view_gas_key
 */
export type JsonRpcRequestForExperimentalViewGasKey = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_view_gas_key';
    params: RpcViewGasKeyRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_view_gas_key_list
 */
export type JsonRpcRequestForExperimentalViewGasKeyList = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_view_gas_key_list';
    params: RpcViewGasKeyListRequest;
};

/**
 * JsonRpcRequest_for_EXPERIMENTAL_view_state
 */
export type JsonRpcRequestForExperimentalViewState = {
    id: string;
    jsonrpc: string;
    method: 'EXPERIMENTAL_view_state';
    params: RpcViewStateRequest;
};

/**
 * JsonRpcRequest_for_block
 */
export type JsonRpcRequestForBlock = {
    id: string;
    jsonrpc: string;
    method: 'block';
    params: RpcBlockRequest;
};

/**
 * JsonRpcRequest_for_block_effects
 */
export type JsonRpcRequestForBlockEffects = {
    id: string;
    jsonrpc: string;
    method: 'block_effects';
    params: RpcStateChangesInBlockRequest;
};

/**
 * JsonRpcRequest_for_broadcast_tx_async
 */
export type JsonRpcRequestForBroadcastTxAsync = {
    id: string;
    jsonrpc: string;
    method: 'broadcast_tx_async';
    params: RpcSendTransactionRequest;
};

/**
 * JsonRpcRequest_for_broadcast_tx_commit
 */
export type JsonRpcRequestForBroadcastTxCommit = {
    id: string;
    jsonrpc: string;
    method: 'broadcast_tx_commit';
    params: RpcSendTransactionRequest;
};

/**
 * JsonRpcRequest_for_changes
 */
export type JsonRpcRequestForChanges = {
    id: string;
    jsonrpc: string;
    method: 'changes';
    params: RpcStateChangesInBlockByTypeRequest;
};

/**
 * JsonRpcRequest_for_chunk
 */
export type JsonRpcRequestForChunk = {
    id: string;
    jsonrpc: string;
    method: 'chunk';
    params: RpcChunkRequest;
};

/**
 * JsonRpcRequest_for_client_config
 */
export type JsonRpcRequestForClientConfig = {
    id: string;
    jsonrpc: string;
    method: 'client_config';
    params: RpcClientConfigRequest;
};

/**
 * JsonRpcRequest_for_gas_price
 */
export type JsonRpcRequestForGasPrice = {
    id: string;
    jsonrpc: string;
    method: 'gas_price';
    params: RpcGasPriceRequest;
};

/**
 * JsonRpcRequest_for_genesis_config
 */
export type JsonRpcRequestForGenesisConfig = {
    id: string;
    jsonrpc: string;
    method: 'genesis_config';
    params: GenesisConfigRequest;
};

/**
 * JsonRpcRequest_for_health
 */
export type JsonRpcRequestForHealth = {
    id: string;
    jsonrpc: string;
    method: 'health';
    params: RpcHealthRequest;
};

/**
 * JsonRpcRequest_for_light_client_proof
 */
export type JsonRpcRequestForLightClientProof = {
    id: string;
    jsonrpc: string;
    method: 'light_client_proof';
    params: RpcLightClientExecutionProofRequest;
};

/**
 * JsonRpcRequest_for_maintenance_windows
 */
export type JsonRpcRequestForMaintenanceWindows = {
    id: string;
    jsonrpc: string;
    method: 'maintenance_windows';
    params: RpcMaintenanceWindowsRequest;
};

/**
 * JsonRpcRequest_for_network_info
 */
export type JsonRpcRequestForNetworkInfo = {
    id: string;
    jsonrpc: string;
    method: 'network_info';
    params: RpcNetworkInfoRequest;
};

/**
 * JsonRpcRequest_for_next_light_client_block
 */
export type JsonRpcRequestForNextLightClientBlock = {
    id: string;
    jsonrpc: string;
    method: 'next_light_client_block';
    params: RpcLightClientNextBlockRequest;
};

/**
 * JsonRpcRequest_for_query
 */
export type JsonRpcRequestForQuery = {
    id: string;
    jsonrpc: string;
    method: 'query';
    params: RpcQueryRequest;
};

/**
 * JsonRpcRequest_for_send_tx
 */
export type JsonRpcRequestForSendTx = {
    id: string;
    jsonrpc: string;
    method: 'send_tx';
    params: RpcSendTransactionRequest;
};

/**
 * JsonRpcRequest_for_status
 */
export type JsonRpcRequestForStatus = {
    id: string;
    jsonrpc: string;
    method: 'status';
    params: RpcStatusRequest;
};

/**
 * JsonRpcRequest_for_tx
 */
export type JsonRpcRequestForTx = {
    id: string;
    jsonrpc: string;
    method: 'tx';
    params: RpcTransactionStatusRequest;
};

/**
 * JsonRpcRequest_for_validators
 */
export type JsonRpcRequestForValidators = {
    id: string;
    jsonrpc: string;
    method: 'validators';
    params: RpcValidatorRequest;
};

export type JsonRpcResponseForArrayOfRangeOfUint64AndRpcMaintenanceWindowsError = (
    | {
          result: Array<RangeOfUint64>;
      }
    | {
          error: ErrorWrapperForRpcMaintenanceWindowsError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForArrayOfValidatorStakeViewAndRpcValidatorError = (
    | {
          result: Array<ValidatorStakeView>;
      }
    | {
          error: ErrorWrapperForRpcValidatorError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForCryptoHashAndRpcTransactionError = (
    | {
          result: CryptoHash;
      }
    | {
          error: ErrorWrapperForRpcTransactionError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForGenesisConfigAndGenesisConfigError = (
    | {
          result: GenesisConfig;
      }
    | {
          error: ErrorWrapperForGenesisConfigError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForNullableRpcHealthResponseAndRpcStatusError = (
    | {
          result: RpcHealthResponse | null;
      }
    | {
          error: ErrorWrapperForRpcStatusError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcBlockResponseAndRpcBlockError = (
    | {
          result: RpcBlockResponse;
      }
    | {
          error: ErrorWrapperForRpcBlockError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcCallFunctionResponseAndRpcCallFunctionError = (
    | {
          result: RpcCallFunctionResponse;
      }
    | {
          error: ErrorWrapperForRpcCallFunctionError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcChunkResponseAndRpcChunkError = (
    | {
          result: RpcChunkResponse;
      }
    | {
          error: ErrorWrapperForRpcChunkError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcClientConfigResponseAndRpcClientConfigError = (
    | {
          result: RpcClientConfigResponse;
      }
    | {
          error: ErrorWrapperForRpcClientConfigError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcCongestionLevelResponseAndRpcChunkError = (
    | {
          result: RpcCongestionLevelResponse;
      }
    | {
          error: ErrorWrapperForRpcChunkError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcGasPriceResponseAndRpcGasPriceError = (
    | {
          result: RpcGasPriceResponse;
      }
    | {
          error: ErrorWrapperForRpcGasPriceError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcLightClientProofError = (
    | {
          result: RpcLightClientBlockProofResponse;
      }
    | {
          error: ErrorWrapperForRpcLightClientProofError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcLightClientProofError = (
    | {
          result: RpcLightClientExecutionProofResponse;
      }
    | {
          error: ErrorWrapperForRpcLightClientProofError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcLightClientNextBlockError = (
    | {
          result: RpcLightClientNextBlockResponse;
      }
    | {
          error: ErrorWrapperForRpcLightClientNextBlockError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcNetworkInfoResponseAndRpcNetworkInfoError = (
    | {
          result: RpcNetworkInfoResponse;
      }
    | {
          error: ErrorWrapperForRpcNetworkInfoError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcProtocolConfigResponseAndRpcProtocolConfigError = (
    | {
          result: RpcProtocolConfigResponse;
      }
    | {
          error: ErrorWrapperForRpcProtocolConfigError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcQueryResponseAndRpcQueryError = (
    | {
          result: RpcQueryResponse;
      }
    | {
          error: ErrorWrapperForRpcQueryError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcReceiptResponseAndRpcReceiptError = (
    | {
          result: RpcReceiptResponse;
      }
    | {
          error: ErrorWrapperForRpcReceiptError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcSplitStorageInfoError = (
    | {
          result: RpcSplitStorageInfoResponse;
      }
    | {
          error: ErrorWrapperForRpcSplitStorageInfoError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcStateChangesError = (
    | {
          result: RpcStateChangesInBlockByTypeResponse;
      }
    | {
          error: ErrorWrapperForRpcStateChangesError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcStateChangesError = (
    | {
          result: RpcStateChangesInBlockResponse;
      }
    | {
          error: ErrorWrapperForRpcStateChangesError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcStatusResponseAndRpcStatusError = (
    | {
          result: RpcStatusResponse;
      }
    | {
          error: ErrorWrapperForRpcStatusError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError = (
    | {
          result: RpcTransactionResponse;
      }
    | {
          error: ErrorWrapperForRpcTransactionError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcValidatorResponseAndRpcValidatorError = (
    | {
          result: RpcValidatorResponse;
      }
    | {
          error: ErrorWrapperForRpcValidatorError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcViewAccessKeyListResponseAndRpcViewAccessKeyListError = (
    | {
          result: RpcViewAccessKeyListResponse;
      }
    | {
          error: ErrorWrapperForRpcViewAccessKeyListError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcViewAccessKeyResponseAndRpcViewAccessKeyError = (
    | {
          result: RpcViewAccessKeyResponse;
      }
    | {
          error: ErrorWrapperForRpcViewAccessKeyError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcViewAccountResponseAndRpcViewAccountError = (
    | {
          result: RpcViewAccountResponse;
      }
    | {
          error: ErrorWrapperForRpcViewAccountError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcViewCodeResponseAndRpcViewCodeError = (
    | {
          result: RpcViewCodeResponse;
      }
    | {
          error: ErrorWrapperForRpcViewCodeError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcViewGasKeyListResponseAndRpcViewGasKeyListError = (
    | {
          result: RpcViewGasKeyListResponse;
      }
    | {
          error: ErrorWrapperForRpcViewGasKeyListError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcViewGasKeyResponseAndRpcViewGasKeyError = (
    | {
          result: RpcViewGasKeyResponse;
      }
    | {
          error: ErrorWrapperForRpcViewGasKeyError;
      }
) & {
    id: string;
    jsonrpc: string;
};

export type JsonRpcResponseForRpcViewStateResponseAndRpcViewStateError = (
    | {
          result: RpcViewStateResponse;
      }
    | {
          error: ErrorWrapperForRpcViewStateError;
      }
) & {
    id: string;
    jsonrpc: string;
};

/**
 * Information about a Producer: its account name, peer_id and a list of connected peers that
 * the node can use to send message for this producer.
 */
export type KnownProducerView = {
    account_id: AccountId;
    next_hops?: Array<PublicKey> | null;
    peer_id: PublicKey;
};

export type LightClientBlockLiteView = {
    inner_lite: BlockHeaderInnerLiteView;
    inner_rest_hash: CryptoHash;
    prev_block_hash: CryptoHash;
};

/**
 * Describes limits for VM and Runtime.
 * TODO #4139: consider switching to strongly-typed wrappers instead of raw quantities
 */
export type LimitConfig = {
    /**
     * Whether to enforce account_id well-formed-ness where it wasn't enforced
     * historically.
     */
    account_id_validity_rules_version?: AccountIdValidityRulesVersion;
    /**
     * The initial number of memory pages.
     * NOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages.
     */
    initial_memory_pages?: number;
    /**
     * Max number of actions per receipt.
     */
    max_actions_per_receipt?: number;
    /**
     * Max length of arguments in a function call action.
     */
    max_arguments_length?: number;
    /**
     * Max contract size
     */
    max_contract_size?: number;
    /**
     * If present, stores max number of elements in a single contract's table
     */
    max_elements_per_contract_table?: number | null;
    /**
     * If present, stores max number of functions in one contract
     */
    max_functions_number_per_contract?: number | null;
    /**
     * Max amount of gas that can be used, excluding gas attached to promises.
     */
    max_gas_burnt?: NearGas;
    /**
     * Max length of any method name (without terminating character).
     */
    max_length_method_name?: number;
    /**
     * Max length of returned data
     */
    max_length_returned_data?: number;
    /**
     * Max storage key size
     */
    max_length_storage_key?: number;
    /**
     * Max storage value size
     */
    max_length_storage_value?: number;
    /**
     * If present, stores max number of locals declared globally in one contract
     */
    max_locals_per_contract?: number | null;
    /**
     * What is the maximal memory pages amount is allowed to have for a contract.
     */
    max_memory_pages?: number;
    /**
     * Max total length of all method names (including terminating character) for a function call
     * permission access key.
     */
    max_number_bytes_method_names?: number;
    /**
     * Max number of input data dependencies
     */
    max_number_input_data_dependencies?: number;
    /**
     * Maximum number of log entries.
     */
    max_number_logs?: number;
    /**
     * Maximum number of registers that can be used simultaneously.
     *
     * Note that due to an implementation quirk [read: a bug] in VMLogic, if we
     * have this number of registers, no subsequent writes to the registers
     * will succeed even if they replace an existing register.
     */
    max_number_registers?: number;
    /**
     * Max number of promises that a function call can create
     */
    max_promises_per_function_call_action?: number;
    /**
     * Max receipt size
     */
    max_receipt_size?: number;
    /**
     * Maximum number of bytes that can be stored in a single register.
     */
    max_register_size?: number;
    /**
     * How tall the stack is allowed to grow?
     *
     * See <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost
     * is calculated.
     */
    max_stack_height?: number;
    /**
     * If present, stores max number of tables declared globally in one contract
     */
    max_tables_per_contract?: number | null;
    /**
     * Maximum total length in bytes of all log messages.
     */
    max_total_log_length?: number;
    /**
     * Max total prepaid gas for all function call actions per receipt.
     */
    max_total_prepaid_gas?: NearGas;
    /**
     * Max transaction size
     */
    max_transaction_size?: number;
    /**
     * Maximum number of bytes for payload passed over a yield resume.
     */
    max_yield_payload_size?: number;
    /**
     * Hard limit on the size of storage proof generated while executing a single receipt.
     */
    per_receipt_storage_proof_size_limit?: number;
    /**
     * Limit of memory used by registers.
     */
    registers_memory_limit?: number;
    /**
     * Number of blocks after which a yielded promise times out.
     */
    yield_timeout_length_in_blocks?: number;
};

export const LogSummaryStyle = { PLAIN: 'plain', COLORED: 'colored' } as const;

export type LogSummaryStyle = (typeof LogSummaryStyle)[keyof typeof LogSummaryStyle];

export type MerklePathItem = {
    direction: Direction;
    hash: CryptoHash;
};

export const MethodResolveError = {
    METHOD_EMPTY_NAME: 'MethodEmptyName',
    METHOD_NOT_FOUND: 'MethodNotFound',
    METHOD_INVALID_SIGNATURE: 'MethodInvalidSignature',
} as const;

export type MethodResolveError = (typeof MethodResolveError)[keyof typeof MethodResolveError];

export type MissingTrieValue = {
    context: MissingTrieValueContext;
    hash: CryptoHash;
};

/**
 * Contexts in which `StorageError::MissingTrieValue` error might occur.
 */
export type MissingTrieValueContext =
    | 'TrieIterator'
    | 'TriePrefetchingStorage'
    | 'TrieMemoryPartialStorage'
    | 'TrieStorage';

export type MutableConfigValue = string;

export type NearGas = number;

export type NearToken = string;

export type NetworkInfoView = {
    connected_peers: Array<PeerInfoView>;
    known_producers: Array<KnownProducerView>;
    num_connected_peers: number;
    peer_max_count: number;
    tier1_accounts_data: Array<AccountDataView>;
    tier1_accounts_keys: Array<PublicKey>;
    tier1_connections: Array<PeerInfoView>;
};

export type NextEpochValidatorInfo = {
    account_id: AccountId;
    public_key: PublicKey;
    shards: Array<ShardId>;
    stake: NearToken;
};

/**
 * An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.
 */
export type NonDelegateAction =
    | {
          CreateAccount: CreateAccountAction;
      }
    | {
          DeployContract: DeployContractAction;
      }
    | {
          FunctionCall: FunctionCallAction;
      }
    | {
          Transfer: TransferAction;
      }
    | {
          Stake: StakeAction;
      }
    | {
          AddKey: AddKeyAction;
      }
    | {
          DeleteKey: DeleteKeyAction;
      }
    | {
          DeleteAccount: DeleteAccountAction;
      }
    | {
          DeployGlobalContract: DeployGlobalContractAction;
      }
    | {
          UseGlobalContract: UseGlobalContractAction;
      }
    | {
          DeterministicStateInit: DeterministicStateInitAction;
      }
    | {
          AddGasKey: AddGasKeyAction;
      }
    | {
          DeleteGasKey: DeleteGasKeyAction;
      }
    | {
          TransferToGasKey: TransferToGasKeyAction;
      };

/**
 * Peer id is the public key.
 */
export type PeerId = PublicKey;

export type PeerInfoView = {
    account_id?: AccountId | null;
    addr: string;
    archival: boolean;
    block_hash?: CryptoHash | null;
    connection_established_time_millis: number;
    height?: number | null;
    is_highest_block_invalid: boolean;
    is_outbound_peer: boolean;
    last_time_peer_requested_millis: number;
    last_time_received_message_millis: number;
    /**
     * Connection nonce.
     */
    nonce: number;
    peer_id: PublicKey;
    received_bytes_per_sec: number;
    sent_bytes_per_sec: number;
    tracked_shards: Array<ShardId>;
};

/**
 * Error that can occur while preparing or executing Wasm smart-contract.
 */
export type PrepareError =
    | 'Serialization'
    | 'Deserialization'
    | 'InternalMemoryDeclared'
    | 'GasInstrumentation'
    | 'StackHeightInstrumentation'
    | 'Instantiate'
    | 'Memory'
    | 'TooManyFunctions'
    | 'TooManyLocals'
    | 'TooManyTables'
    | 'TooManyTableElements';

/**
 * Configures whether the node checks the next or the next next epoch for network version compatibility.
 */
export const ProtocolVersionCheckConfig = { NEXT: 'Next', NEXT_NEXT: 'NextNext' } as const;

/**
 * Configures whether the node checks the next or the next next epoch for network version compatibility.
 */
export type ProtocolVersionCheckConfig = (typeof ProtocolVersionCheckConfig)[keyof typeof ProtocolVersionCheckConfig];

export type PublicKey = string;

export type RangeOfUint64 = {
    end: number;
    start: number;
};

export type ReceiptEnumView =
    | {
          Action: {
              actions: Array<ActionView>;
              gas_price: NearToken;
              input_data_ids: Array<CryptoHash>;
              is_promise_yield?: boolean;
              output_data_receivers: Array<DataReceiverView>;
              refund_to?: AccountId | null;
              signer_id: AccountId;
              signer_public_key: PublicKey;
          };
      }
    | {
          Data: {
              data?: string | null;
              data_id: CryptoHash;
              is_promise_resume?: boolean;
          };
      }
    | {
          GlobalContractDistribution: {
              already_delivered_shards: Array<ShardId>;
              code: string;
              id: GlobalContractIdentifier;
              target_shard: ShardId;
          };
      };

/**
 * Describes the error for validating a receipt.
 */
export type ReceiptValidationError =
    | {
          InvalidPredecessorId: {
              account_id: string;
          };
      }
    | {
          InvalidReceiverId: {
              account_id: string;
          };
      }
    | {
          InvalidSignerId: {
              account_id: string;
          };
      }
    | {
          InvalidDataReceiverId: {
              account_id: string;
          };
      }
    | {
          ReturnedValueLengthExceeded: {
              length: number;
              limit: number;
          };
      }
    | {
          NumberInputDataDependenciesExceeded: {
              limit: number;
              number_of_input_data_dependencies: number;
          };
      }
    | {
          ActionsValidation: ActionsValidationError;
      }
    | {
          ReceiptSizeExceeded: {
              limit: number;
              size: number;
          };
      }
    | {
          InvalidRefundTo: {
              account_id: string;
          };
      };

export type ReceiptView = {
    predecessor_id: AccountId;
    priority?: number;
    receipt: ReceiptEnumView;
    receipt_id: CryptoHash;
    receiver_id: AccountId;
};

export type RpcBlockError =
    | {
          info: {
              [key: string]: unknown;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          name: 'NOT_SYNCED_YET';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

/**
 * RpcBlockRequest
 */
export type RpcBlockRequest =
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      };

export type RpcBlockResponse = {
    /**
     * The AccountId of the author of the Block
     */
    author: AccountId;
    chunks: Array<ChunkHeaderView>;
    header: BlockHeaderView;
};

export type RpcCallFunctionError =
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              contract_account_id: AccountId;
          };
          name: 'NO_CONTRACT_CODE';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              vm_error: FunctionCallError;
          };
          name: 'CONTRACT_EXECUTION_ERROR';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcCallFunctionRequest = (
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      }
) & {
    account_id: AccountId;
    args_base64: FunctionArgs;
    method_name: string;
};

/**
 * A result returned by contract method
 */
export type RpcCallFunctionResponse = {
    block_hash: CryptoHash;
    block_height: number;
    logs: Array<string>;
    result: Array<number>;
};

export type RpcChunkError =
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      }
    | {
          info: {
              [key: string]: unknown;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              shard_id: ShardId;
          };
          name: 'INVALID_SHARD_ID';
      }
    | {
          info: {
              chunk_hash: CryptoHash;
          };
          name: 'UNKNOWN_CHUNK';
      };

/**
 * RpcChunkRequest
 */
export type RpcChunkRequest =
    | {
          block_id: BlockId;
          shard_id: ShardId;
      }
    | {
          chunk_id: CryptoHash;
      };

export type RpcChunkResponse = {
    author: AccountId;
    header: ChunkHeaderView;
    receipts: Array<ReceiptView>;
    transactions: Array<SignedTransactionView>;
};

export type RpcClientConfigError = {
    info: {
        error_message: string;
    };
    name: 'INTERNAL_ERROR';
};

/**
 * RpcClientConfigRequest
 */
export const RpcClientConfigRequest = { NULL: null } as const;

/**
 * RpcClientConfigRequest
 */
export type RpcClientConfigRequest = (typeof RpcClientConfigRequest)[keyof typeof RpcClientConfigRequest];

/**
 * ClientConfig where some fields can be updated at runtime.
 */
export type RpcClientConfigResponse = {
    /**
     * Not clear old data, set `true` for archive nodes.
     */
    archive?: boolean;
    /**
     * Horizon at which instead of fetching block, fetch full state.
     */
    block_fetch_horizon?: number;
    /**
     * Behind this horizon header fetch kicks in.
     */
    block_header_fetch_horizon?: number;
    /**
     * Duration to check for producing / skipping block.
     */
    block_production_tracking_delay?: [number, number];
    /**
     * Time between check to perform catchup.
     */
    catchup_step_period?: [number, number];
    /**
     * Chain id for status.
     */
    chain_id?: string;
    /**
     * Optional config for the Chunk Distribution Network feature.
     * If set to `None` then this node does not participate in the Chunk Distribution Network.
     * Nodes not participating will still function fine, but possibly with higher
     * latency due to the need of requesting chunks over the peer-to-peer network.
     */
    chunk_distribution_network?: ChunkDistributionNetworkConfig | null;
    /**
     * Time between checking to re-request chunks.
     */
    chunk_request_retry_period?: [number, number];
    /**
     * Number of threads for ChunkValidationActor pool.
     */
    chunk_validation_threads?: number;
    /**
     * Multiplier for the wait time for all chunks to be received.
     */
    chunk_wait_mult?: [number, number];
    /**
     * Height horizon for the chunk cache. A chunk is removed from the cache
     * if its height + chunks_cache_height_horizon < largest_seen_height.
     * The default value is DEFAULT_CHUNKS_CACHE_HEIGHT_HORIZON.
     */
    chunks_cache_height_horizon?: number;
    /**
     * Number of threads to execute background migration work in client.
     */
    client_background_migration_threads?: number;
    /**
     * Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and
     * writes chunk-related data based on the tracked shards.
     */
    cloud_archival_writer?: CloudArchivalWriterConfig | null;
    /**
     * If true, the node won't forward transactions to next the chunk producers.
     */
    disable_tx_routing?: boolean;
    /**
     * Time between running doomslug timer.
     */
    doomslug_step_period?: [number, number];
    /**
     * If true, transactions for the next chunk will be prepared early, right after the previous chunk's
     * post-state is ready. This can help produce chunks faster, for high-throughput chains.
     * The current implementation increases latency on low-load chains, which will be fixed in the future.
     * The default is disabled.
     */
    enable_early_prepare_transactions?: boolean;
    enable_multiline_logging?: boolean;
    /**
     * Re-export storage layer statistics as prometheus metrics.
     */
    enable_statistics_export?: boolean;
    /**
     * Epoch length.
     */
    epoch_length?: number;
    /**
     * Options for epoch sync.
     */
    epoch_sync?: EpochSyncConfig;
    /**
     * Graceful shutdown at expected block height.
     */
    expected_shutdown?: MutableConfigValue;
    /**
     * Garbage collection configuration.
     */
    gc?: GcConfig;
    /**
     * Expected increase of header head height per second during header sync
     */
    header_sync_expected_height_per_second?: number;
    /**
     * How much time to wait after initial header sync
     */
    header_sync_initial_timeout?: [number, number];
    /**
     * How much time to wait after some progress is made in header sync
     */
    header_sync_progress_timeout?: [number, number];
    /**
     * How much time to wait before banning a peer in header sync if sync is too slow
     */
    header_sync_stall_ban_timeout?: [number, number];
    /**
     * Period between logging summary information.
     */
    log_summary_period?: [number, number];
    /**
     * Enable coloring of the logs
     */
    log_summary_style?: LogSummaryStyle;
    /**
     * Maximum wait for approvals before producing block.
     */
    max_block_production_delay?: [number, number];
    /**
     * Maximum duration before skipping given height.
     */
    max_block_wait_delay?: [number, number];
    /**
     * Max burnt gas per view method.  If present, overrides value stored in
     * genesis file.  The value only affects the RPCs without influencing the
     * protocol thus changing it per-node doesn’t affect the blockchain.
     */
    max_gas_burnt_view?: NearGas | null;
    /**
     * Minimum duration before producing block.
     */
    min_block_production_delay?: [number, number];
    /**
     * Minimum number of peers to start syncing.
     */
    min_num_peers?: number;
    /**
     * Number of block producer seats
     */
    num_block_producer_seats?: number;
    /**
     * Maximum size of state witnesses in the OrphanStateWitnessPool.
     *
     * We keep only orphan witnesses which are smaller than this size.
     * This limits the maximum memory usage of OrphanStateWitnessPool.
     */
    orphan_state_witness_max_size?: number;
    /**
     * OrphanStateWitnessPool keeps instances of ChunkStateWitness which can't be processed
     * because the previous block isn't available. The witnesses wait in the pool until the
     * required block appears. This variable controls how many witnesses can be stored in the pool.
     */
    orphan_state_witness_pool_size?: number;
    /**
     * Limit the time of adding transactions to a chunk.
     * A node produces a chunk by adding transactions from the transaction pool until
     * some limit is reached. This time limit ensures that adding transactions won't take
     * longer than the specified duration, which helps to produce the chunk quickly.
     */
    produce_chunk_add_transactions_time_limit?: string;
    /**
     * Produce empty blocks, use `false` for testing.
     */
    produce_empty_blocks?: boolean;
    /**
     * Determines whether client should exit if the protocol version is not supported
     * for the next or next next epoch.
     */
    protocol_version_check?: ProtocolVersionCheckConfig;
    resharding_config?: MutableConfigValue;
    /**
     * Listening rpc port for status.
     */
    rpc_addr?: string | null;
    /**
     * Save observed instances of invalid ChunkStateWitness to the database in DBCol::InvalidChunkStateWitnesses.
     * Saving invalid witnesses is useful for analysis and debugging.
     * This option can cause extra load on the database and is not recommended for production use.
     */
    save_invalid_witnesses?: boolean;
    /**
     * Save observed instances of ChunkStateWitness to the database in DBCol::LatestChunkStateWitnesses.
     * Saving the latest witnesses is useful for analysis and debugging.
     * This option can cause extra load on the database and is not recommended for production use.
     */
    save_latest_witnesses?: boolean;
    /**
     * Whether to persist state changes on disk or not.
     */
    save_state_changes?: boolean;
    /**
     * save_trie_changes should be set to true iff
     * - archive if false - non-archival nodes need trie changes to perform garbage collection
     * - archive is true, cold_store is configured and migration to split_storage is finished - node
     * working in split storage mode needs trie changes in order to do garbage collection on hot.
     */
    save_trie_changes?: boolean;
    /**
     * Whether to persist transaction outcomes to disk or not.
     */
    save_tx_outcomes?: boolean;
    /**
     * Whether to persist partial chunk parts for untracked shards or not.
     */
    save_untracked_partial_chunks_parts?: boolean;
    /**
     * Skip waiting for sync (for testing or single node testnet).
     */
    skip_sync_wait?: boolean;
    /**
     * Number of threads for StateRequestActor pool.
     */
    state_request_server_threads?: number;
    /**
     * Number of seconds between state requests for view client.
     * Throttling window for state requests (headers and parts).
     */
    state_request_throttle_period?: [number, number];
    /**
     * Maximum number of state requests served per throttle period
     */
    state_requests_per_throttle_period?: number;
    /**
     * Options for syncing state.
     */
    state_sync?: StateSyncConfig;
    /**
     * Whether to use the State Sync mechanism.
     * If disabled, the node will do Block Sync instead of State Sync.
     */
    state_sync_enabled?: boolean;
    /**
     * Additional waiting period after a failed request to external storage
     */
    state_sync_external_backoff?: [number, number];
    /**
     * How long to wait for a response from centralized state sync
     */
    state_sync_external_timeout?: [number, number];
    /**
     * How long to wait for a response from p2p state sync
     */
    state_sync_p2p_timeout?: [number, number];
    /**
     * How long to wait after a failed state sync request
     */
    state_sync_retry_backoff?: [number, number];
    /**
     * How often to check that we are not out of sync.
     */
    sync_check_period?: [number, number];
    /**
     * Sync height threshold: below this difference in height don't start syncing.
     */
    sync_height_threshold?: number;
    /**
     * Maximum number of block requests to send to peers to sync
     */
    sync_max_block_requests?: number;
    /**
     * While syncing, how long to check for each step.
     */
    sync_step_period?: [number, number];
    tracked_shards_config?: TrackedShardsConfig;
    /**
     * Limit of the size of per-shard transaction pool measured in bytes. If not set, the size
     * will be unbounded.
     */
    transaction_pool_size_limit?: number | null;
    transaction_request_handler_threads?: number;
    /**
     * Upper bound of the byte size of contract state that is still viewable. None is no limit
     */
    trie_viewer_state_size_limit?: number | null;
    /**
     * Time to persist Accounts Id in the router without removing them.
     */
    ttl_account_id_router?: [number, number];
    /**
     * If the node is not a chunk producer within that many blocks, then route
     * to upcoming chunk producers.
     */
    tx_routing_height_horizon?: number;
    /**
     * Version of the binary.
     */
    version?: Version;
    /**
     * Number of threads for ViewClientActor pool.
     */
    view_client_threads?: number;
};

/**
 * RpcCongestionLevelRequest
 */
export type RpcCongestionLevelRequest =
    | {
          block_id: BlockId;
          shard_id: ShardId;
      }
    | {
          chunk_id: CryptoHash;
      };

export type RpcCongestionLevelResponse = {
    congestion_level: number;
};

export type RpcGasPriceError =
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      }
    | {
          info: {
              [key: string]: unknown;
          };
          name: 'UNKNOWN_BLOCK';
      };

/**
 * RpcGasPriceRequest
 */
export type RpcGasPriceRequest = {
    block_id?: BlockId | null;
};

export type RpcGasPriceResponse = {
    gas_price: NearToken;
};

/**
 * RpcHealthRequest
 */
export const RpcHealthRequest = { NULL: null } as const;

/**
 * RpcHealthRequest
 */
export type RpcHealthRequest = (typeof RpcHealthRequest)[keyof typeof RpcHealthRequest];

export const RpcHealthResponse = { NULL: null } as const;

export type RpcHealthResponse = (typeof RpcHealthResponse)[keyof typeof RpcHealthResponse];

export type RpcKnownProducer = {
    account_id: AccountId;
    addr?: string | null;
    peer_id: PeerId;
};

/**
 * RpcLightClientBlockProofRequest
 */
export type RpcLightClientBlockProofRequest = {
    block_hash: CryptoHash;
    light_client_head: CryptoHash;
};

export type RpcLightClientBlockProofResponse = {
    block_header_lite: LightClientBlockLiteView;
    block_proof: Array<MerklePathItem>;
};

export type RpcLightClientExecutionProofRequest = (
    | {
          sender_id: AccountId;
          transaction_hash: CryptoHash;
          type: 'transaction';
      }
    | {
          receipt_id: CryptoHash;
          receiver_id: AccountId;
          type: 'receipt';
      }
) & {
    light_client_head: CryptoHash;
};

export type RpcLightClientExecutionProofResponse = {
    block_header_lite: LightClientBlockLiteView;
    block_proof: Array<MerklePathItem>;
    outcome_proof: ExecutionOutcomeWithIdView;
    outcome_root_proof: Array<MerklePathItem>;
};

export type RpcLightClientNextBlockError =
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      }
    | {
          info: {
              [key: string]: unknown;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              epoch_id: EpochId;
          };
          name: 'EPOCH_OUT_OF_BOUNDS';
      };

/**
 * RpcLightClientNextBlockRequest
 */
export type RpcLightClientNextBlockRequest = {
    last_block_hash: CryptoHash;
};

/**
 * A state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).
 */
export type RpcLightClientNextBlockResponse = {
    approvals_after_next?: Array<Signature | null>;
    /**
     * Inner part of the block header that gets hashed, split into two parts, one that is sent
     * to light clients, and the rest
     */
    inner_lite?: BlockHeaderInnerLiteView;
    inner_rest_hash?: CryptoHash;
    next_block_inner_hash?: CryptoHash;
    next_bps?: Array<ValidatorStakeView> | null;
    prev_block_hash?: CryptoHash;
};

export type RpcLightClientProofError =
    | {
          info: {
              [key: string]: unknown;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              execution_outcome_shard_id: ShardId;
              number_or_shards: number;
          };
          name: 'INCONSISTENT_STATE';
      }
    | {
          info: {
              transaction_or_receipt_id: CryptoHash;
          };
          name: 'NOT_CONFIRMED';
      }
    | {
          info: {
              transaction_or_receipt_id: CryptoHash;
          };
          name: 'UNKNOWN_TRANSACTION_OR_RECEIPT';
      }
    | {
          info: {
              shard_id: ShardId;
              transaction_or_receipt_id: CryptoHash;
          };
          name: 'UNAVAILABLE_SHARD';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcMaintenanceWindowsError = {
    info: {
        error_message: string;
    };
    name: 'INTERNAL_ERROR';
};

/**
 * RpcMaintenanceWindowsRequest
 */
export type RpcMaintenanceWindowsRequest = {
    account_id: AccountId;
};

export type RpcNetworkInfoError = {
    info: {
        error_message: string;
    };
    name: 'INTERNAL_ERROR';
};

/**
 * RpcNetworkInfoRequest
 */
export const RpcNetworkInfoRequest = { NULL: null } as const;

/**
 * RpcNetworkInfoRequest
 */
export type RpcNetworkInfoRequest = (typeof RpcNetworkInfoRequest)[keyof typeof RpcNetworkInfoRequest];

export type RpcNetworkInfoResponse = {
    active_peers: Array<RpcPeerInfo>;
    /**
     * Accounts of known block and chunk producers from routing table.
     */
    known_producers: Array<RpcKnownProducer>;
    num_active_peers: number;
    peer_max_count: number;
    received_bytes_per_sec: number;
    sent_bytes_per_sec: number;
};

export type RpcPeerInfo = {
    account_id?: AccountId | null;
    addr?: string | null;
    id: PeerId;
};

export type RpcProtocolConfigError =
    | {
          info: {
              [key: string]: unknown;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

/**
 * RpcProtocolConfigRequest
 */
export type RpcProtocolConfigRequest =
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      };

export type RpcProtocolConfigResponse = {
    /**
     * Expected number of hidden validators per shard.
     */
    avg_hidden_validator_seats_per_shard?: Array<number>;
    /**
     * Threshold for kicking out block producers, between 0 and 100.
     */
    block_producer_kickout_threshold?: number;
    /**
     * ID of the blockchain. This must be unique for every blockchain.
     * If your testnet blockchains do not have unique chain IDs, you will have a bad time.
     */
    chain_id?: string;
    /**
     * Threshold for kicking out chunk producers, between 0 and 100.
     */
    chunk_producer_kickout_threshold?: number;
    /**
     * Threshold for kicking out nodes which are only chunk validators, between 0 and 100.
     */
    chunk_validator_only_kickout_threshold?: number;
    /**
     * Enable dynamic re-sharding.
     */
    dynamic_resharding?: boolean;
    /**
     * Epoch length counted in block heights.
     */
    epoch_length?: number;
    /**
     * Fishermen stake threshold.
     */
    fishermen_threshold?: NearToken;
    /**
     * Initial gas limit.
     */
    gas_limit?: NearGas;
    /**
     * Gas price adjustment rate
     */
    gas_price_adjustment_rate?: [number, number];
    /**
     * Height of genesis block.
     */
    genesis_height?: number;
    /**
     * Official time of blockchain start.
     */
    genesis_time?: string;
    /**
     * Maximum gas price.
     */
    max_gas_price?: NearToken;
    /**
     * Maximum inflation on the total supply every epoch.
     */
    max_inflation_rate?: [number, number];
    /**
     * Max stake percentage of the validators we will kick out.
     */
    max_kickout_stake_perc?: number;
    /**
     * Minimum gas price. It is also the initial gas price.
     */
    min_gas_price?: NearToken;
    /**
     * The minimum stake required for staking is last seat price divided by this number.
     */
    minimum_stake_divisor?: number;
    /**
     * The lowest ratio s/s_total any block producer can have.
     * See <https://github.com/near/NEPs/pull/167> for details
     */
    minimum_stake_ratio?: [number, number];
    /**
     * The minimum number of validators each shard must have
     */
    minimum_validators_per_shard?: number;
    /**
     * Number of block producer seats at genesis.
     */
    num_block_producer_seats?: number;
    /**
     * Defines number of shards and number of block producer seats per each shard at genesis.
     */
    num_block_producer_seats_per_shard?: Array<number>;
    /**
     * Expected number of blocks per year
     */
    num_blocks_per_year?: number;
    /**
     * Online maximum threshold above which validator gets full reward.
     */
    online_max_threshold?: [number, number];
    /**
     * Online minimum threshold below which validator doesn't receive reward.
     */
    online_min_threshold?: [number, number];
    /**
     * Protocol treasury rate
     */
    protocol_reward_rate?: [number, number];
    /**
     * Protocol treasury account
     */
    protocol_treasury_account?: AccountId;
    /**
     * Threshold of stake that needs to indicate that they ready for upgrade.
     */
    protocol_upgrade_stake_threshold?: [number, number];
    /**
     * Current Protocol Version
     */
    protocol_version?: number;
    /**
     * Runtime configuration (mostly economics constants).
     */
    runtime_config?: RuntimeConfigView;
    /**
     * Layout information regarding how to split accounts to shards
     */
    shard_layout?: ShardLayout;
    /**
     * If true, shuffle the chunk producers across shards. In other words, if
     * the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents
     * the set of chunk producers for shard `i`, if this flag were true, the
     * shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.
     */
    shuffle_shard_assignment_for_chunk_producers?: boolean;
    /**
     * Number of target chunk validator mandates for each shard.
     */
    target_validator_mandates_per_shard?: number;
    /**
     * Number of blocks for which a given transaction is valid
     */
    transaction_validity_period?: number;
};

export type RpcQueryError =
    | {
          name: 'NO_SYNCED_BLOCKS';
      }
    | {
          info: {
              requested_shard_id: ShardId;
          };
          name: 'UNAVAILABLE_SHARD';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
          };
          name: 'GARBAGE_COLLECTED_BLOCK';
      }
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              contract_account_id: AccountId;
          };
          name: 'NO_CONTRACT_CODE';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              contract_account_id: AccountId;
          };
          name: 'TOO_LARGE_CONTRACT_STATE';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              public_key: PublicKey;
          };
          name: 'UNKNOWN_ACCESS_KEY';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              public_key: PublicKey;
          };
          name: 'UNKNOWN_GAS_KEY';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              error: FunctionCallError;
              vm_error: string;
          };
          name: 'CONTRACT_EXECUTION_ERROR';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              identifier: GlobalContractIdentifier;
          };
          name: 'NO_GLOBAL_CONTRACT_CODE';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

/**
 * RpcQueryRequest
 */
export type RpcQueryRequest =
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          request_type: 'view_account';
      })
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          request_type: 'view_code';
      })
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          include_proof?: boolean;
          prefix_base64: StoreKey;
          request_type: 'view_state';
      })
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          public_key: PublicKey;
          request_type: 'view_access_key';
      })
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          request_type: 'view_access_key_list';
      })
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          public_key: PublicKey;
          request_type: 'view_gas_key';
      })
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          request_type: 'view_gas_key_list';
      })
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          args_base64: FunctionArgs;
          method_name: string;
          request_type: 'call_function';
      })
    | ({
          block_id: BlockId;
      } & {
          code_hash: CryptoHash;
          request_type: 'view_global_contract_code';
      })
    | ({
          block_id: BlockId;
      } & {
          account_id: AccountId;
          request_type: 'view_global_contract_code_by_account_id';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          request_type: 'view_account';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          request_type: 'view_code';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          include_proof?: boolean;
          prefix_base64: StoreKey;
          request_type: 'view_state';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          public_key: PublicKey;
          request_type: 'view_access_key';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          request_type: 'view_access_key_list';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          public_key: PublicKey;
          request_type: 'view_gas_key';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          request_type: 'view_gas_key_list';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          args_base64: FunctionArgs;
          method_name: string;
          request_type: 'call_function';
      })
    | ({
          finality: Finality;
      } & {
          code_hash: CryptoHash;
          request_type: 'view_global_contract_code';
      })
    | ({
          finality: Finality;
      } & {
          account_id: AccountId;
          request_type: 'view_global_contract_code_by_account_id';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          request_type: 'view_account';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          request_type: 'view_code';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          include_proof?: boolean;
          prefix_base64: StoreKey;
          request_type: 'view_state';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          public_key: PublicKey;
          request_type: 'view_access_key';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          request_type: 'view_access_key_list';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          public_key: PublicKey;
          request_type: 'view_gas_key';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          request_type: 'view_gas_key_list';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          args_base64: FunctionArgs;
          method_name: string;
          request_type: 'call_function';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          code_hash: CryptoHash;
          request_type: 'view_global_contract_code';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_id: AccountId;
          request_type: 'view_global_contract_code_by_account_id';
      });

export type RpcQueryResponse = (
    | AccountView
    | ContractCodeView
    | ViewStateResult
    | CallResult
    | AccessKeyView
    | AccessKeyList
    | GasKeyView
    | GasKeyList
) & {
    block_hash: CryptoHash;
    block_height: number;
};

export type RpcReceiptError =
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      }
    | {
          info: {
              receipt_id: CryptoHash;
          };
          name: 'UNKNOWN_RECEIPT';
      };

/**
 * RpcReceiptRequest
 */
export type RpcReceiptRequest = {
    receipt_id: CryptoHash;
};

export type RpcReceiptResponse = {
    predecessor_id: AccountId;
    priority?: number;
    receipt: ReceiptEnumView;
    receipt_id: CryptoHash;
    receiver_id: AccountId;
};

export type RpcRequestValidationErrorKind =
    | {
          info: {
              method_name: string;
          };
          name: 'METHOD_NOT_FOUND';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'PARSE_ERROR';
      };

/**
 * RpcSendTransactionRequest
 */
export type RpcSendTransactionRequest = {
    signed_tx_base64: SignedTransaction;
    wait_until?: TxExecutionStatus;
};

export type RpcSplitStorageInfoError = {
    info: {
        error_message: string;
    };
    name: 'INTERNAL_ERROR';
};

/**
 * RpcSplitStorageInfoRequest
 */
export type RpcSplitStorageInfoRequest = {
    [key: string]: unknown;
};

/**
 * Contains the split storage information.
 */
export type RpcSplitStorageInfoResponse = {
    cold_head_height?: number | null;
    final_head_height?: number | null;
    head_height?: number | null;
    hot_db_kind?: string | null;
};

export type RpcStateChangesError =
    | {
          info: {
              [key: string]: unknown;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          name: 'NOT_SYNCED_YET';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

/**
 * RpcStateChangesInBlockByTypeRequest
 *
 * It is a [serializable view] of [`StateChangesRequest`].
 *
 * [serializable view]: ./index.html
 * [`StateChangesRequest`]: ../types/struct.StateChangesRequest.html
 */
export type RpcStateChangesInBlockByTypeRequest =
    | ({
          block_id: BlockId;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'account_changes';
      })
    | ({
          block_id: BlockId;
      } & {
          changes_type: 'single_access_key_changes';
          keys: Array<AccountWithPublicKey>;
      })
    | ({
          block_id: BlockId;
      } & {
          changes_type: 'single_gas_key_changes';
          keys: Array<AccountWithPublicKey>;
      })
    | ({
          block_id: BlockId;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'all_access_key_changes';
      })
    | ({
          block_id: BlockId;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'all_gas_key_changes';
      })
    | ({
          block_id: BlockId;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'contract_code_changes';
      })
    | ({
          block_id: BlockId;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'data_changes';
          key_prefix_base64: StoreKey;
      })
    | ({
          finality: Finality;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'account_changes';
      })
    | ({
          finality: Finality;
      } & {
          changes_type: 'single_access_key_changes';
          keys: Array<AccountWithPublicKey>;
      })
    | ({
          finality: Finality;
      } & {
          changes_type: 'single_gas_key_changes';
          keys: Array<AccountWithPublicKey>;
      })
    | ({
          finality: Finality;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'all_access_key_changes';
      })
    | ({
          finality: Finality;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'all_gas_key_changes';
      })
    | ({
          finality: Finality;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'contract_code_changes';
      })
    | ({
          finality: Finality;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'data_changes';
          key_prefix_base64: StoreKey;
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'account_changes';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          changes_type: 'single_access_key_changes';
          keys: Array<AccountWithPublicKey>;
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          changes_type: 'single_gas_key_changes';
          keys: Array<AccountWithPublicKey>;
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'all_access_key_changes';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'all_gas_key_changes';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'contract_code_changes';
      })
    | ({
          sync_checkpoint: SyncCheckpoint;
      } & {
          account_ids: Array<AccountId>;
          changes_type: 'data_changes';
          key_prefix_base64: StoreKey;
      });

export type RpcStateChangesInBlockByTypeResponse = {
    block_hash: CryptoHash;
    changes: Array<StateChangeKindView>;
};

/**
 * RpcStateChangesInBlockRequest
 */
export type RpcStateChangesInBlockRequest =
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      };

export type RpcStateChangesInBlockResponse = {
    block_hash: CryptoHash;
    changes: Array<StateChangeWithCauseView>;
};

export type RpcStatusError =
    | {
          name: 'NODE_IS_SYNCING';
      }
    | {
          info: {
              elapsed: [number, number];
          };
          name: 'NO_NEW_BLOCKS';
      }
    | {
          info: {
              epoch_id: EpochId;
          };
          name: 'EPOCH_OUT_OF_BOUNDS';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

/**
 * RpcStatusRequest
 */
export const RpcStatusRequest = { NULL: null } as const;

/**
 * RpcStatusRequest
 */
export type RpcStatusRequest = (typeof RpcStatusRequest)[keyof typeof RpcStatusRequest];

export type RpcStatusResponse = {
    /**
     * Unique chain id.
     */
    chain_id: string;
    /**
     * Information about last blocks, network, epoch and chain & chunk info.
     */
    detailed_debug_status?: DetailedDebugStatus | null;
    /**
     * Genesis hash of the chain.
     */
    genesis_hash: CryptoHash;
    /**
     * Latest protocol version that this client supports.
     */
    latest_protocol_version: number;
    /**
     * Deprecated; same as `validator_public_key` which you should use instead.
     */
    node_key?: PublicKey | null;
    /**
     * Public key of the node.
     */
    node_public_key: PublicKey;
    /**
     * Currently active protocol version.
     */
    protocol_version: number;
    /**
     * Address for RPC server.  None if node doesn't have RPC endpoint enabled.
     */
    rpc_addr?: string | null;
    /**
     * Sync status of the node.
     */
    sync_info: StatusSyncInfo;
    /**
     * Uptime of the node.
     */
    uptime_sec: number;
    /**
     * Validator id of the node
     */
    validator_account_id?: AccountId | null;
    /**
     * Public key of the validator.
     */
    validator_public_key?: PublicKey | null;
    /**
     * Current epoch validators.
     */
    validators: Array<ValidatorInfo>;
    /**
     * Binary version.
     */
    version: Version;
};

export type RpcTransactionError =
    | {
          info: {
              [key: string]: unknown;
          };
          name: 'INVALID_TRANSACTION';
      }
    | {
          name: 'DOES_NOT_TRACK_SHARD';
      }
    | {
          info: {
              transaction_hash: CryptoHash;
          };
          name: 'REQUEST_ROUTED';
      }
    | {
          info: {
              requested_transaction_hash: CryptoHash;
          };
          name: 'UNKNOWN_TRANSACTION';
      }
    | {
          info: {
              debug_info: string;
          };
          name: 'INTERNAL_ERROR';
      }
    | {
          name: 'TIMEOUT_ERROR';
      };

export type RpcTransactionResponse = (FinalExecutionOutcomeWithReceiptView | FinalExecutionOutcomeView) & {
    final_execution_status: TxExecutionStatus;
};

export type RpcTransactionStatusRequest = (
    | {
          signed_tx_base64: SignedTransaction;
      }
    | {
          sender_account_id: AccountId;
          tx_hash: CryptoHash;
      }
) & {
    wait_until?: TxExecutionStatus;
};

export type RpcValidatorError =
    | {
          name: 'UNKNOWN_EPOCH';
      }
    | {
          name: 'VALIDATOR_INFO_UNAVAILABLE';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

/**
 * RpcValidatorRequest
 */
export type RpcValidatorRequest =
    | 'latest'
    | {
          epoch_id: EpochId;
      }
    | {
          block_id: BlockId;
      };

/**
 * Information about this epoch validators and next epoch validators
 */
export type RpcValidatorResponse = {
    /**
     * Fishermen for the current epoch
     */
    current_fishermen: Array<ValidatorStakeView>;
    /**
     * Proposals in the current epoch
     */
    current_proposals: Array<ValidatorStakeView>;
    /**
     * Validators for the current epoch
     */
    current_validators: Array<CurrentEpochValidatorInfo>;
    /**
     * Epoch height
     */
    epoch_height: number;
    /**
     * Epoch start block height
     */
    epoch_start_height: number;
    /**
     * Fishermen for the next epoch
     */
    next_fishermen: Array<ValidatorStakeView>;
    /**
     * Validators for the next epoch
     */
    next_validators: Array<NextEpochValidatorInfo>;
    /**
     * Kickout in the previous epoch
     */
    prev_epoch_kickout: Array<ValidatorKickoutView>;
};

/**
 * RpcValidatorsOrderedRequest
 */
export type RpcValidatorsOrderedRequest = {
    block_id?: BlockId | null;
};

export type RpcViewAccessKeyError =
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              public_key: PublicKey;
          };
          name: 'UNKNOWN_ACCESS_KEY';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcViewAccessKeyListError =
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcViewAccessKeyListRequest = (
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      }
) & {
    account_id: AccountId;
};

/**
 * Lists access keys
 */
export type RpcViewAccessKeyListResponse = {
    block_hash: CryptoHash;
    block_height: number;
    keys: Array<AccessKeyInfoView>;
};

export type RpcViewAccessKeyRequest = (
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      }
) & {
    account_id: AccountId;
    public_key: PublicKey;
};

/**
 * Describes access key permission scope and nonce.
 */
export type RpcViewAccessKeyResponse = {
    block_hash: CryptoHash;
    block_height: number;
    nonce: number;
    permission: AccessKeyPermissionView;
};

export type RpcViewAccountError =
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcViewAccountRequest = (
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      }
) & {
    account_id: AccountId;
};

/**
 * A view of the account
 */
export type RpcViewAccountResponse = {
    amount: NearToken;
    block_hash: CryptoHash;
    block_height: number;
    code_hash: CryptoHash;
    global_contract_account_id?: AccountId | null;
    global_contract_hash?: CryptoHash | null;
    locked: NearToken;
    /**
     * TODO(2271): deprecated.
     */
    storage_paid_at?: number;
    storage_usage: number;
};

export type RpcViewCodeError =
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              contract_account_id: AccountId;
          };
          name: 'NO_CONTRACT_CODE';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcViewCodeRequest = (
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      }
) & {
    account_id: AccountId;
};

/**
 * A view of the contract code.
 */
export type RpcViewCodeResponse = {
    block_hash: CryptoHash;
    block_height: number;
    code_base64: string;
    hash: CryptoHash;
};

export type RpcViewGasKeyError =
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              public_key: PublicKey;
          };
          name: 'UNKNOWN_GAS_KEY';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcViewGasKeyListError =
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcViewGasKeyListRequest = (
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      }
) & {
    account_id: AccountId;
};

export type RpcViewGasKeyListResponse = {
    block_hash: CryptoHash;
    block_height: number;
    keys: Array<GasKeyInfoView>;
};

export type RpcViewGasKeyRequest = (
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      }
) & {
    account_id: AccountId;
    public_key: PublicKey;
};

export type RpcViewGasKeyResponse = {
    balance: NearToken;
    block_hash: CryptoHash;
    block_height: number;
    nonces: Array<number>;
    num_nonces: number;
    permission: AccessKeyPermissionView;
};

export type RpcViewStateError =
    | {
          info: {
              block_reference: BlockReference;
          };
          name: 'UNKNOWN_BLOCK';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'INVALID_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              requested_account_id: AccountId;
          };
          name: 'UNKNOWN_ACCOUNT';
      }
    | {
          info: {
              block_hash: CryptoHash;
              block_height: number;
              contract_account_id: AccountId;
          };
          name: 'TOO_LARGE_CONTRACT_STATE';
      }
    | {
          info: {
              error_message: string;
          };
          name: 'INTERNAL_ERROR';
      };

export type RpcViewStateRequest = (
    | {
          block_id: BlockId;
      }
    | {
          finality: Finality;
      }
    | {
          sync_checkpoint: SyncCheckpoint;
      }
) & {
    account_id: AccountId;
    include_proof?: boolean;
    prefix_base64: StoreKey;
};

/**
 * Resulting state values for a view state query request
 */
export type RpcViewStateResponse = {
    block_hash: CryptoHash;
    block_height: number;
    proof?: Array<string>;
    values: Array<StateItem>;
};

/**
 * View that preserves JSON format of the runtime config.
 */
export type RuntimeConfigView = {
    /**
     * Config that defines rules for account creation.
     */
    account_creation_config?: AccountCreationConfigView;
    /**
     * The configuration for congestion control.
     */
    congestion_control_config?: CongestionControlConfigView;
    /**
     * Configuration for dynamic resharding feature.
     */
    dynamic_resharding_config?: DynamicReshardingConfigView;
    /**
     * Amount of yN per byte required to have on the account.  See
     * <https://nomicon.io/Economics/Economics.html#state-stake> for details.
     */
    storage_amount_per_byte?: NearToken;
    /**
     * Costs of different actions that need to be performed when sending and
     * processing transaction and receipts.
     */
    transaction_costs?: RuntimeFeesConfigView;
    /**
     * Config of wasm operations.
     */
    wasm_config?: VmConfigView;
    /**
     * Configuration specific to ChunkStateWitness.
     */
    witness_config?: WitnessConfigView;
};

/**
 * Describes different fees for the runtime
 */
export type RuntimeFeesConfigView = {
    /**
     * Describes the cost of creating a certain action, `Action`. Includes all variants.
     */
    action_creation_config?: ActionCreationConfigView;
    /**
     * Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost
     * of actions.
     * - `send` cost is burned when a receipt is created using `promise_create` or
     * `promise_batch_create`
     * - `exec` cost is burned when the receipt is being executed.
     */
    action_receipt_creation_config?: Fee;
    /**
     * Fraction of the burnt gas to reward to the contract account for execution.
     */
    burnt_gas_reward?: [number, number];
    /**
     * Describes the cost of creating a data receipt, `DataReceipt`.
     */
    data_receipt_creation_config?: DataReceiptCreationConfigView;
    /**
     * Pessimistic gas price inflation ratio.
     */
    pessimistic_gas_price_inflation_ratio?: [number, number];
    /**
     * Describes fees for storage.
     */
    storage_usage_config?: StorageUsageConfigView;
};

/**
 * The shard identifier. It may be an arbitrary number - it does not need to be
 * a number in the range 0..NUM_SHARDS. The shard ids do not need to be
 * sequential or contiguous.
 *
 * The shard id is wrapped in a new type to prevent the old pattern of using
 * indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition
 * if fully complete it potentially may be simplified to a regular type alias.
 */
export type ShardId = number;

/**
 * A versioned struct that contains all information needed to assign accounts to shards.
 *
 * Because of re-sharding, the chain may use different shard layout to split shards at different
 * times. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each
 * epoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since
 * re-sharding has only happened once. It is stored as part of genesis config, see
 * default_simple_nightshade_shard_layout() Below is an overview for some important
 * functionalities of ShardLayout interface.
 */
export type ShardLayout =
    | {
          V0: ShardLayoutV0;
      }
    | {
          V1: ShardLayoutV1;
      }
    | {
          V2: ShardLayoutV2;
      }
    | {
          V3: ShardLayoutV3;
      };

/**
 * A shard layout that maps accounts evenly across all shards -- by calculate the hash of account
 * id and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,
 * to keep backward compatibility for some existing tests.
 * `parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout
 * a chain uses.
 */
export type ShardLayoutV0 = {
    /**
     * Map accounts evenly across all shards
     */
    num_shards: number;
    /**
     * Version of the shard layout, this is useful for uniquely identify the shard layout
     */
    version: number;
};

export type ShardLayoutV1 = {
    /**
     * The boundary accounts are the accounts on boundaries between shards.
     * Each shard contains a range of accounts from one boundary account to
     * another - or the smallest or largest account possible. The total
     * number of shards is equal to the number of boundary accounts plus 1.
     */
    boundary_accounts: Array<AccountId>;
    /**
     * Maps shards from the last shard layout to shards that it splits to in this shard layout,
     * Useful for constructing states for the shards.
     * None for the genesis shard layout
     */
    shards_split_map?: Array<Array<ShardId>> | null;
    /**
     * Maps shard in this shard layout to their parent shard
     * Since shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap
     */
    to_parent_shard_map?: Array<ShardId> | null;
    /**
     * Version of the shard layout, this is useful for uniquely identify the shard layout
     */
    version: number;
};

/**
 * Counterpart to `ShardLayoutV2` composed of maps with string keys to aid
 * serde serialization.
 */
export type ShardLayoutV2 = {
    boundary_accounts: Array<AccountId>;
    id_to_index_map: {
        [key: string]: number;
    };
    index_to_id_map: {
        [key: string]: ShardId;
    };
    shard_ids: Array<ShardId>;
    shards_parent_map?: {
        [key: string]: ShardId;
    } | null;
    shards_split_map?: {
        [key: string]: Array<ShardId>;
    } | null;
    version: number;
};

/**
 * Counterpart to `ShardLayoutV3` composed of maps with string keys to aid
 * serde serialization.
 */
export type ShardLayoutV3 = {
    boundary_accounts: Array<AccountId>;
    id_to_index_map: {
        [key: string]: number;
    };
    last_split: ShardId;
    shard_ids: Array<ShardId>;
    shards_split_map: {
        [key: string]: Array<ShardId>;
    };
};

/**
 * `ShardUId` is a unique representation for shards from different shard layouts.
 *
 * Comparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,
 * `ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.
 * This is important because we store states indexed by shards in our database, so we need a
 * way to unique identify shard even when shards change across epochs.
 * Another difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in
 * a node's internal state while `ShardId` can be exposed to outside APIs and used in protocol
 * level information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)
 */
export type ShardUId = {
    shard_id: number;
    version: number;
};

export type Signature = string;

export type SignedDelegateAction = {
    delegate_action: DelegateAction;
    signature: Signature;
};

export type SignedTransaction = string;

export type SignedTransactionView = {
    actions: Array<ActionView>;
    hash: CryptoHash;
    nonce: number;
    priority_fee?: number;
    public_key: PublicKey;
    receiver_id: AccountId;
    signature: Signature;
    signer_id: AccountId;
};

export type SlashedValidator = {
    account_id: AccountId;
    is_double_sign: boolean;
};

/**
 * An action which stakes signer_id tokens and setup's validator public key
 */
export type StakeAction = {
    /**
     * Validator key which will be used to sign transactions on behalf of signer_id
     */
    public_key: PublicKey;
    /**
     * Amount of tokens to stake.
     */
    stake: NearToken;
};

/**
 * See crate::types::StateChangeCause for details.
 */
export type StateChangeCauseView =
    | {
          type: 'not_writable_to_disk';
      }
    | {
          type: 'initial_state';
      }
    | {
          tx_hash: CryptoHash;
          type: 'transaction_processing';
      }
    | {
          receipt_hash: CryptoHash;
          type: 'action_receipt_processing_started';
      }
    | {
          receipt_hash: CryptoHash;
          type: 'action_receipt_gas_reward';
      }
    | {
          receipt_hash: CryptoHash;
          type: 'receipt_processing';
      }
    | {
          receipt_hash: CryptoHash;
          type: 'postponed_receipt';
      }
    | {
          type: 'updated_delayed_receipts';
      }
    | {
          type: 'validator_accounts_update';
      }
    | {
          type: 'migration';
      }
    | {
          type: 'bandwidth_scheduler_state_update';
      };

/**
 * It is a [serializable view] of [`StateChangeKind`].
 *
 * [serializable view]: ./index.html
 * [`StateChangeKind`]: ../types/struct.StateChangeKind.html
 */
export type StateChangeKindView =
    | {
          account_id: AccountId;
          type: 'account_touched';
      }
    | {
          account_id: AccountId;
          type: 'access_key_touched';
      }
    | {
          account_id: AccountId;
          type: 'data_touched';
      }
    | {
          account_id: AccountId;
          type: 'contract_code_touched';
      };

export type StateChangeWithCauseView = (
    | {
          /**
           * A view of the account
           */
          change: {
              account_id: AccountId;
              amount: NearToken;
              code_hash: CryptoHash;
              global_contract_account_id?: AccountId | null;
              global_contract_hash?: CryptoHash | null;
              locked: NearToken;
              /**
               * TODO(2271): deprecated.
               */
              storage_paid_at?: number;
              storage_usage: number;
          };
          type: 'account_update';
      }
    | {
          change: {
              account_id: AccountId;
          };
          type: 'account_deletion';
      }
    | {
          change: {
              access_key: AccessKeyView;
              account_id: AccountId;
              public_key: PublicKey;
          };
          type: 'access_key_update';
      }
    | {
          change: {
              account_id: AccountId;
              public_key: PublicKey;
          };
          type: 'access_key_deletion';
      }
    | {
          change: {
              account_id: AccountId;
              gas_key: GasKey;
              public_key: PublicKey;
          };
          type: 'gas_key_update';
      }
    | {
          change: {
              account_id: AccountId;
              index: number;
              nonce: number;
              public_key: PublicKey;
          };
          type: 'gas_key_nonce_update';
      }
    | {
          change: {
              account_id: AccountId;
              public_key: PublicKey;
          };
          type: 'gas_key_deletion';
      }
    | {
          change: {
              account_id: AccountId;
              key_base64: StoreKey;
              value_base64: StoreValue;
          };
          type: 'data_update';
      }
    | {
          change: {
              account_id: AccountId;
              key_base64: StoreKey;
          };
          type: 'data_deletion';
      }
    | {
          change: {
              account_id: AccountId;
              code_base64: string;
          };
          type: 'contract_code_update';
      }
    | {
          change: {
              account_id: AccountId;
          };
          type: 'contract_code_deletion';
      }
) & {
    cause: StateChangeCauseView;
};

/**
 * Item of the state, key and value are serialized in base64 and proof for inclusion of given state item.
 */
export type StateItem = {
    key: StoreKey;
    value: StoreValue;
};

export type StateSyncConfig = {
    concurrency?: SyncConcurrency;
    /**
     * `none` value disables state dump to external storage.
     */
    dump?: DumpConfig | null;
    /**
     * Zstd compression level for state parts.
     */
    parts_compression_lvl?: number;
    sync?: SyncConfig;
};

export type StatusSyncInfo = {
    earliest_block_hash?: CryptoHash | null;
    earliest_block_height?: number | null;
    earliest_block_time?: string | null;
    epoch_id?: EpochId | null;
    epoch_start_height?: number | null;
    latest_block_hash: CryptoHash;
    latest_block_height: number;
    latest_block_time: string;
    latest_state_root: CryptoHash;
    syncing: boolean;
};

/**
 * Errors which may occur during working with trie storages, storing
 * trie values (trie nodes and state values) by their hashes.
 */
export type StorageError =
    | 'StorageInternalError'
    | {
          MissingTrieValue: MissingTrieValue;
      }
    | 'UnexpectedTrieValue'
    | {
          StorageInconsistentState: string;
      }
    | {
          FlatStorageBlockNotSupported: string;
      }
    | {
          MemTrieLoadingError: string;
      };

/**
 * This enum represents if a storage_get call will be performed through flat storage or trie
 */
export const StorageGetMode = { FLAT_STORAGE: 'FlatStorage', TRIE: 'Trie' } as const;

/**
 * This enum represents if a storage_get call will be performed through flat storage or trie
 */
export type StorageGetMode = (typeof StorageGetMode)[keyof typeof StorageGetMode];

/**
 * Describes cost of storage per block
 */
export type StorageUsageConfigView = {
    /**
     * Number of bytes for an account record, including rounding up for account id.
     */
    num_bytes_account?: number;
    /**
     * Additional number of bytes for a k/v record
     */
    num_extra_bytes_record?: number;
};

/**
 * This type is used to mark keys (arrays of bytes) that are queried from store.
 *
 * NOTE: Currently, this type is only used in the view_client and RPC to be able to transparently
 * pretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).
 */
export type StoreKey = string;

/**
 * This type is used to mark values returned from store (arrays of bytes).
 *
 * NOTE: Currently, this type is only used in the view_client and RPC to be able to transparently
 * pretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).
 */
export type StoreValue = string;

export const SyncCheckpoint = { GENESIS: 'genesis', EARLIEST_AVAILABLE: 'earliest_available' } as const;

export type SyncCheckpoint = (typeof SyncCheckpoint)[keyof typeof SyncCheckpoint];

export type SyncConcurrency = {
    /**
     * Maximum number of "apply parts" tasks that can be performed in parallel.
     * This is a very disk-heavy task and therefore we set this to a low limit,
     * or else the rocksdb contention makes the whole server freeze up.
     */
    apply?: number;
    /**
     * Maximum number of "apply parts" tasks that can be performed in parallel
     * during catchup. We set this to a very low value to avoid overloading the
     * node while it is still performing normal tasks.
     */
    apply_during_catchup?: number;
    /**
     * Maximum number of outstanding requests for decentralized state sync.
     */
    peer_downloads?: number;
    /**
     * The maximum parallelism to use per shard. This is mostly for fairness, because
     * the actual rate limiting is done by the TaskTrackers, but this is useful for
     * balancing the shards a little.
     */
    per_shard?: number;
};

/**
 * Configures how to fetch state parts during state sync.
 */
export type SyncConfig =
    | 'Peers'
    | {
          ExternalStorage: ExternalStorageConfig;
      };

export type Tier1ProxyView = {
    addr: string;
    peer_id: PublicKey;
};

/**
 * Describes the expected behavior of the node regarding shard tracking.
 * If the node is an active validator, it will also track the shards it is responsible for as a validator.
 */
export type TrackedShardsConfig =
    | 'NoShards'
    | {
          Shards: Array<ShardUId>;
      }
    | 'AllShards'
    | {
          ShadowValidator: AccountId;
      }
    | {
          Schedule: Array<Array<ShardId>>;
      }
    | {
          Accounts: Array<AccountId>;
      };

export type TransferAction = {
    deposit: NearToken;
};

export type TransferToGasKeyAction = {
    deposit: NearToken;
    public_key: PublicKey;
};

/**
 * Error returned in the ExecutionOutcome in case of failure
 */
export type TxExecutionError =
    | {
          ActionError: ActionError;
      }
    | {
          InvalidTxError: InvalidTxError;
      };

export type TxExecutionStatus = 'NONE' | 'INCLUDED' | 'EXECUTED_OPTIMISTIC' | 'INCLUDED_FINAL' | 'EXECUTED' | 'FINAL';

/**
 * Use global contract action
 */
export type UseGlobalContractAction = {
    contract_identifier: GlobalContractIdentifier;
};

export type VmConfigView = {
    /**
     * See [VMConfig::deterministic_account_ids](crate::vm::Config::deterministic_account_ids).
     */
    deterministic_account_ids?: boolean;
    /**
     * See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections).
     */
    discard_custom_sections?: boolean;
    /**
     * See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts).
     */
    eth_implicit_accounts?: boolean;
    /**
     * Costs for runtime externals
     */
    ext_costs?: ExtCostsConfigView;
    /**
     * See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost).
     */
    fix_contract_loading_cost?: boolean;
    /**
     * See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns).
     */
    global_contract_host_fns?: boolean;
    /**
     * Gas cost of a growing memory by single page.
     */
    grow_mem_cost?: number;
    /**
     * Deprecated
     */
    implicit_account_creation?: boolean;
    /**
     * Describes limits for VM and Runtime.
     *
     * TODO: Consider changing this to `VMLimitConfigView` to avoid dependency
     * on runtime.
     */
    limit_config?: LimitConfig;
    /**
     * Base gas cost of a linear operation
     */
    linear_op_base_cost?: number;
    /**
     * Unit gas cost of a linear operation
     */
    linear_op_unit_cost?: number;
    /**
     * See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory).
     */
    reftypes_bulk_memory?: boolean;
    /**
     * Gas cost of a regular operation.
     */
    regular_op_cost?: number;
    /**
     * See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int).
     */
    saturating_float_to_int?: boolean;
    /**
     * See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode).
     */
    storage_get_mode?: StorageGetMode;
    /**
     * See [VMConfig::vm_kind](crate::vm::Config::vm_kind).
     */
    vm_kind?: VmKind;
};

export type VmKind = 'Wasmer0' | 'Wasmtime' | 'Wasmer2' | 'NearVm';

export type ValidatorInfo = {
    account_id: AccountId;
};

/**
 * Reasons for removing a validator from the validator set.
 */
export type ValidatorKickoutReason =
    | '_UnusedSlashed'
    | {
          NotEnoughBlocks: {
              expected: number;
              produced: number;
          };
      }
    | {
          NotEnoughChunks: {
              expected: number;
              produced: number;
          };
      }
    | 'Unstaked'
    | {
          NotEnoughStake: {
              stake_u128: NearToken;
              threshold_u128: NearToken;
          };
      }
    | 'DidNotGetASeat'
    | {
          NotEnoughChunkEndorsements: {
              expected: number;
              produced: number;
          };
      }
    | {
          ProtocolVersionTooOld: {
              network_version: number;
              version: number;
          };
      };

export type ValidatorKickoutView = {
    account_id: AccountId;
    reason: ValidatorKickoutReason;
};

export type ValidatorStakeView = ValidatorStakeViewV1 & {
    validator_stake_struct_version: 'V1';
};

export type ValidatorStakeViewV1 = {
    account_id: AccountId;
    public_key: PublicKey;
    stake: NearToken;
};

/**
 * Data structure for semver version and github tag or commit.
 */
export type Version = {
    build: string;
    commit: string;
    rustc_version?: string;
    version: string;
};

/**
 * Resulting state values for a view state query request
 */
export type ViewStateResult = {
    proof?: Array<string>;
    values: Array<StateItem>;
};

/**
 * A kind of a trap happened during execution of a binary
 */
export type WasmTrap =
    | 'Unreachable'
    | 'IncorrectCallIndirectSignature'
    | 'MemoryOutOfBounds'
    | 'CallIndirectOOB'
    | 'IllegalArithmetic'
    | 'MisalignedAtomicAccess'
    | 'IndirectCallToNull'
    | 'StackOverflow'
    | 'GenericTrap';

/**
 * Configuration specific to ChunkStateWitness.
 */
export type WitnessConfigView = {
    /**
     * Maximum size of transactions contained inside ChunkStateWitness.
     *
     * A witness contains transactions from both the previous chunk and the current one.
     * This parameter limits the sum of sizes of transactions from both of those chunks.
     */
    combined_transactions_size_limit?: number;
    /**
     * Size limit for storage proof generated while executing receipts in a chunk.
     * After this limit is reached we defer execution of any new receipts.
     */
    main_storage_proof_size_soft_limit?: number;
    /**
     * Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.
     */
    new_transactions_validation_state_size_soft_limit?: number;
};

export type ExperimentalCallFunctionData = {
    body: JsonRpcRequestForExperimentalCallFunction;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_call_function';
};

export type ExperimentalCallFunctionResponses = {
    200: JsonRpcResponseForRpcCallFunctionResponseAndRpcCallFunctionError;
};

export type ExperimentalCallFunctionResponse =
    ExperimentalCallFunctionResponses[keyof ExperimentalCallFunctionResponses];

export type ExperimentalChangesData = {
    body: JsonRpcRequestForExperimentalChanges;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_changes';
};

export type ExperimentalChangesResponses = {
    200: JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcStateChangesError;
};

export type ExperimentalChangesResponse = ExperimentalChangesResponses[keyof ExperimentalChangesResponses];

export type ExperimentalChangesInBlockData = {
    body: JsonRpcRequestForExperimentalChangesInBlock;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_changes_in_block';
};

export type ExperimentalChangesInBlockResponses = {
    200: JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcStateChangesError;
};

export type ExperimentalChangesInBlockResponse =
    ExperimentalChangesInBlockResponses[keyof ExperimentalChangesInBlockResponses];

export type ExperimentalCongestionLevelData = {
    body: JsonRpcRequestForExperimentalCongestionLevel;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_congestion_level';
};

export type ExperimentalCongestionLevelResponses = {
    200: JsonRpcResponseForRpcCongestionLevelResponseAndRpcChunkError;
};

export type ExperimentalCongestionLevelResponse =
    ExperimentalCongestionLevelResponses[keyof ExperimentalCongestionLevelResponses];

export type ExperimentalGenesisConfigData = {
    body: JsonRpcRequestForExperimentalGenesisConfig;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_genesis_config';
};

export type ExperimentalGenesisConfigResponses = {
    200: JsonRpcResponseForGenesisConfigAndGenesisConfigError;
};

export type ExperimentalGenesisConfigResponse =
    ExperimentalGenesisConfigResponses[keyof ExperimentalGenesisConfigResponses];

export type ExperimentalLightClientBlockProofData = {
    body: JsonRpcRequestForExperimentalLightClientBlockProof;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_light_client_block_proof';
};

export type ExperimentalLightClientBlockProofResponses = {
    200: JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcLightClientProofError;
};

export type ExperimentalLightClientBlockProofResponse =
    ExperimentalLightClientBlockProofResponses[keyof ExperimentalLightClientBlockProofResponses];

export type ExperimentalLightClientProofData = {
    body: JsonRpcRequestForExperimentalLightClientProof;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_light_client_proof';
};

export type ExperimentalLightClientProofResponses = {
    200: JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcLightClientProofError;
};

export type ExperimentalLightClientProofResponse =
    ExperimentalLightClientProofResponses[keyof ExperimentalLightClientProofResponses];

export type ExperimentalMaintenanceWindowsData = {
    body: JsonRpcRequestForExperimentalMaintenanceWindows;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_maintenance_windows';
};

export type ExperimentalMaintenanceWindowsResponses = {
    200: JsonRpcResponseForArrayOfRangeOfUint64AndRpcMaintenanceWindowsError;
};

export type ExperimentalMaintenanceWindowsResponse =
    ExperimentalMaintenanceWindowsResponses[keyof ExperimentalMaintenanceWindowsResponses];

export type ExperimentalProtocolConfigData = {
    body: JsonRpcRequestForExperimentalProtocolConfig;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_protocol_config';
};

export type ExperimentalProtocolConfigResponses = {
    200: JsonRpcResponseForRpcProtocolConfigResponseAndRpcProtocolConfigError;
};

export type ExperimentalProtocolConfigResponse =
    ExperimentalProtocolConfigResponses[keyof ExperimentalProtocolConfigResponses];

export type ExperimentalReceiptData = {
    body: JsonRpcRequestForExperimentalReceipt;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_receipt';
};

export type ExperimentalReceiptResponses = {
    200: JsonRpcResponseForRpcReceiptResponseAndRpcReceiptError;
};

export type ExperimentalReceiptResponse = ExperimentalReceiptResponses[keyof ExperimentalReceiptResponses];

export type ExperimentalSplitStorageInfoData = {
    body: JsonRpcRequestForExperimentalSplitStorageInfo;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_split_storage_info';
};

export type ExperimentalSplitStorageInfoResponses = {
    200: JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcSplitStorageInfoError;
};

export type ExperimentalSplitStorageInfoResponse =
    ExperimentalSplitStorageInfoResponses[keyof ExperimentalSplitStorageInfoResponses];

export type ExperimentalTxStatusData = {
    body: JsonRpcRequestForExperimentalTxStatus;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_tx_status';
};

export type ExperimentalTxStatusResponses = {
    200: JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError;
};

export type ExperimentalTxStatusResponse = ExperimentalTxStatusResponses[keyof ExperimentalTxStatusResponses];

export type ExperimentalValidatorsOrderedData = {
    body: JsonRpcRequestForExperimentalValidatorsOrdered;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_validators_ordered';
};

export type ExperimentalValidatorsOrderedResponses = {
    200: JsonRpcResponseForArrayOfValidatorStakeViewAndRpcValidatorError;
};

export type ExperimentalValidatorsOrderedResponse =
    ExperimentalValidatorsOrderedResponses[keyof ExperimentalValidatorsOrderedResponses];

export type ExperimentalViewAccessKeyData = {
    body: JsonRpcRequestForExperimentalViewAccessKey;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_view_access_key';
};

export type ExperimentalViewAccessKeyResponses = {
    200: JsonRpcResponseForRpcViewAccessKeyResponseAndRpcViewAccessKeyError;
};

export type ExperimentalViewAccessKeyResponse =
    ExperimentalViewAccessKeyResponses[keyof ExperimentalViewAccessKeyResponses];

export type ExperimentalViewAccessKeyListData = {
    body: JsonRpcRequestForExperimentalViewAccessKeyList;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_view_access_key_list';
};

export type ExperimentalViewAccessKeyListResponses = {
    200: JsonRpcResponseForRpcViewAccessKeyListResponseAndRpcViewAccessKeyListError;
};

export type ExperimentalViewAccessKeyListResponse =
    ExperimentalViewAccessKeyListResponses[keyof ExperimentalViewAccessKeyListResponses];

export type ExperimentalViewAccountData = {
    body: JsonRpcRequestForExperimentalViewAccount;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_view_account';
};

export type ExperimentalViewAccountResponses = {
    200: JsonRpcResponseForRpcViewAccountResponseAndRpcViewAccountError;
};

export type ExperimentalViewAccountResponse = ExperimentalViewAccountResponses[keyof ExperimentalViewAccountResponses];

export type ExperimentalViewCodeData = {
    body: JsonRpcRequestForExperimentalViewCode;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_view_code';
};

export type ExperimentalViewCodeResponses = {
    200: JsonRpcResponseForRpcViewCodeResponseAndRpcViewCodeError;
};

export type ExperimentalViewCodeResponse = ExperimentalViewCodeResponses[keyof ExperimentalViewCodeResponses];

export type ExperimentalViewGasKeyData = {
    body: JsonRpcRequestForExperimentalViewGasKey;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_view_gas_key';
};

export type ExperimentalViewGasKeyResponses = {
    200: JsonRpcResponseForRpcViewGasKeyResponseAndRpcViewGasKeyError;
};

export type ExperimentalViewGasKeyResponse = ExperimentalViewGasKeyResponses[keyof ExperimentalViewGasKeyResponses];

export type ExperimentalViewGasKeyListData = {
    body: JsonRpcRequestForExperimentalViewGasKeyList;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_view_gas_key_list';
};

export type ExperimentalViewGasKeyListResponses = {
    200: JsonRpcResponseForRpcViewGasKeyListResponseAndRpcViewGasKeyListError;
};

export type ExperimentalViewGasKeyListResponse =
    ExperimentalViewGasKeyListResponses[keyof ExperimentalViewGasKeyListResponses];

export type ExperimentalViewStateData = {
    body: JsonRpcRequestForExperimentalViewState;
    path?: never;
    query?: never;
    url: '/EXPERIMENTAL_view_state';
};

export type ExperimentalViewStateResponses = {
    200: JsonRpcResponseForRpcViewStateResponseAndRpcViewStateError;
};

export type ExperimentalViewStateResponse = ExperimentalViewStateResponses[keyof ExperimentalViewStateResponses];

export type BlockData = {
    body: JsonRpcRequestForBlock;
    path?: never;
    query?: never;
    url: '/block';
};

export type BlockResponses = {
    200: JsonRpcResponseForRpcBlockResponseAndRpcBlockError;
};

export type BlockResponse = BlockResponses[keyof BlockResponses];

export type BlockEffectsData = {
    body: JsonRpcRequestForBlockEffects;
    path?: never;
    query?: never;
    url: '/block_effects';
};

export type BlockEffectsResponses = {
    200: JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcStateChangesError;
};

export type BlockEffectsResponse = BlockEffectsResponses[keyof BlockEffectsResponses];

export type BroadcastTxAsyncData = {
    body: JsonRpcRequestForBroadcastTxAsync;
    path?: never;
    query?: never;
    url: '/broadcast_tx_async';
};

export type BroadcastTxAsyncResponses = {
    200: JsonRpcResponseForCryptoHashAndRpcTransactionError;
};

export type BroadcastTxAsyncResponse = BroadcastTxAsyncResponses[keyof BroadcastTxAsyncResponses];

export type BroadcastTxCommitData = {
    body: JsonRpcRequestForBroadcastTxCommit;
    path?: never;
    query?: never;
    url: '/broadcast_tx_commit';
};

export type BroadcastTxCommitResponses = {
    200: JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError;
};

export type BroadcastTxCommitResponse = BroadcastTxCommitResponses[keyof BroadcastTxCommitResponses];

export type ChangesData = {
    body: JsonRpcRequestForChanges;
    path?: never;
    query?: never;
    url: '/changes';
};

export type ChangesResponses = {
    200: JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcStateChangesError;
};

export type ChangesResponse = ChangesResponses[keyof ChangesResponses];

export type ChunkData = {
    body: JsonRpcRequestForChunk;
    path?: never;
    query?: never;
    url: '/chunk';
};

export type ChunkResponses = {
    200: JsonRpcResponseForRpcChunkResponseAndRpcChunkError;
};

export type ChunkResponse = ChunkResponses[keyof ChunkResponses];

export type ClientConfigData = {
    body: JsonRpcRequestForClientConfig;
    path?: never;
    query?: never;
    url: '/client_config';
};

export type ClientConfigResponses = {
    200: JsonRpcResponseForRpcClientConfigResponseAndRpcClientConfigError;
};

export type ClientConfigResponse = ClientConfigResponses[keyof ClientConfigResponses];

export type GasPriceData = {
    body: JsonRpcRequestForGasPrice;
    path?: never;
    query?: never;
    url: '/gas_price';
};

export type GasPriceResponses = {
    200: JsonRpcResponseForRpcGasPriceResponseAndRpcGasPriceError;
};

export type GasPriceResponse = GasPriceResponses[keyof GasPriceResponses];

export type GenesisConfigData = {
    body: JsonRpcRequestForGenesisConfig;
    path?: never;
    query?: never;
    url: '/genesis_config';
};

export type GenesisConfigResponses = {
    200: JsonRpcResponseForGenesisConfigAndGenesisConfigError;
};

export type GenesisConfigResponse = GenesisConfigResponses[keyof GenesisConfigResponses];

export type HealthData = {
    body: JsonRpcRequestForHealth;
    path?: never;
    query?: never;
    url: '/health';
};

export type HealthResponses = {
    200: JsonRpcResponseForNullableRpcHealthResponseAndRpcStatusError;
};

export type HealthResponse = HealthResponses[keyof HealthResponses];

export type LightClientProofData = {
    body: JsonRpcRequestForLightClientProof;
    path?: never;
    query?: never;
    url: '/light_client_proof';
};

export type LightClientProofResponses = {
    200: JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcLightClientProofError;
};

export type LightClientProofResponse = LightClientProofResponses[keyof LightClientProofResponses];

export type MaintenanceWindowsData = {
    body: JsonRpcRequestForMaintenanceWindows;
    path?: never;
    query?: never;
    url: '/maintenance_windows';
};

export type MaintenanceWindowsResponses = {
    200: JsonRpcResponseForArrayOfRangeOfUint64AndRpcMaintenanceWindowsError;
};

export type MaintenanceWindowsResponse = MaintenanceWindowsResponses[keyof MaintenanceWindowsResponses];

export type NetworkInfoData = {
    body: JsonRpcRequestForNetworkInfo;
    path?: never;
    query?: never;
    url: '/network_info';
};

export type NetworkInfoResponses = {
    200: JsonRpcResponseForRpcNetworkInfoResponseAndRpcNetworkInfoError;
};

export type NetworkInfoResponse = NetworkInfoResponses[keyof NetworkInfoResponses];

export type NextLightClientBlockData = {
    body: JsonRpcRequestForNextLightClientBlock;
    path?: never;
    query?: never;
    url: '/next_light_client_block';
};

export type NextLightClientBlockResponses = {
    200: JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcLightClientNextBlockError;
};

export type NextLightClientBlockResponse = NextLightClientBlockResponses[keyof NextLightClientBlockResponses];

export type QueryData = {
    body: JsonRpcRequestForQuery;
    path?: never;
    query?: never;
    url: '/query';
};

export type QueryResponses = {
    200: JsonRpcResponseForRpcQueryResponseAndRpcQueryError;
};

export type QueryResponse = QueryResponses[keyof QueryResponses];

export type SendTxData = {
    body: JsonRpcRequestForSendTx;
    path?: never;
    query?: never;
    url: '/send_tx';
};

export type SendTxResponses = {
    200: JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError;
};

export type SendTxResponse = SendTxResponses[keyof SendTxResponses];

export type StatusData = {
    body: JsonRpcRequestForStatus;
    path?: never;
    query?: never;
    url: '/status';
};

export type StatusResponses = {
    200: JsonRpcResponseForRpcStatusResponseAndRpcStatusError;
};

export type StatusResponse = StatusResponses[keyof StatusResponses];

export type TxData = {
    body: JsonRpcRequestForTx;
    path?: never;
    query?: never;
    url: '/tx';
};

export type TxResponses = {
    200: JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError;
};

export type TxResponse = TxResponses[keyof TxResponses];

export type ValidatorsData = {
    body: JsonRpcRequestForValidators;
    path?: never;
    query?: never;
    url: '/validators';
};

export type ValidatorsResponses = {
    200: JsonRpcResponseForRpcValidatorResponseAndRpcValidatorError;
};

export type ValidatorsResponse = ValidatorsResponses[keyof ValidatorsResponses];
